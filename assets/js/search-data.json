{"0": {
    "doc": "Looping",
    "title": "Looping",
    "content": "# Looping This chapter deals with structure loops, not [Process loops]({{ site.baseurl }}/processes.html#process-loops). ## Loop with transitions To enable the repetition of certain parts of a [[scenario]], we use transitions to go \"back in time\". Transitions are instantaneous intervals that can connect two states regardless of their chronological relationship. ![Loop with Transitions]({{ site.img }}/reference/common-practices/loopStructure.gif \"Loop with transitions\") In this case, the loop will go on forever as well as playing and replaying all following intervals. ## Nested loops For more control and to avoid perpetual looping and branching, it may be necessary to isolate a repeating structure in a sub-scenario. Triggering the end of the interval containing the sub-scenario will ensure that the loop stops as well as the execution of the following intervals. ![Nested Loops]({{ site.img }}/reference/common-practices/nestedLoop.gif \"Nested loop\") ## Repetition amount Adding a trigger on the last `Sync` of a loop and setting its maximum duration allows to control the amount of repetition. The trigger left by default to be \"never\" true will still be validated when the maximum duration of the preceding interval has been reached. With this method, the time spent looping is equal to the loop duration + the maximum duration, and can be fine-tuned by manipulating the closing parenthesis. ![repetition amount]({{ site.img }}/reference/common-practices/repetition-ammount.gif \"repetition amount\") ## Loop branches Transitions actually connect to `Syncs` (vertical doted lines), thus, transitioning to a specific `Sync` will execute or re-execute all connected branches. When several transitions are connected to the same `Sync`, the smallest loop will then always restart first and cut short all parallel intervals. ![Loop branches]({{ site.img }}/reference/common-practices/loopBranches.gif \"Loop branches\") Transitions can provide a workaround in this situation. Since transitions are instantaneous intervals, they can also be used to isolate parallel loops without interfering with timing and their original synchronization. ![Isolate transitions]({{ site.img }}/reference/common-practices/isolateTransitions.gif \"Isolate transitions\") ",
    "url": "https://ossia.io/score-docs/common-practices/1-looping.html",
    "relUrl": "/common-practices/1-looping.html"
  },"1": {
    "doc": "Switches",
    "title": "Switches",
    "content": "# Switches ## Single trigger Adding a trigger at either end of a [looping interval]({{ site.baseurl }}/common-practices/1-looping.html#loop-with-transitions) provides control over each repetition. If the trigger is enabled at the beginning of the interval, it controls the start and restarts of the loop. When time reaches the end of the interval, the transition returns to the start `Sync` where the execution is suspended again until re-triggered. In this case, the interval's execution must reach its end before it can be restarted. ![Start trigger switch]({{ site.img }}/reference/common-practices/triggerStart.gif \"Start trigger switch\") If the trigger is enabled at the end of the loop, it provides flexible time to the interval. As soon as the interval begins executing, it can be interrupted by the validation of the trigger and transition back to the beginning. ![End trigger switch]({{ site.img }}/reference/common-practices/triggerEnd.gif \"End trigger switch\") ## On / Off Combining both the above options, an interval can be toggled on and off at will. This method, like the previous, can also be directly mapped to various devices featuring buttons, keys, hardware switches or any kind of discrete value streams. In this case we will use the first button of a game controller accessed through the [Joystick Device]({{ site.baseurl }}/devices/joystick-device.html). ![Basic switch]({{ site.img }}/reference/common-practices/switch.gif \"Basic switch\") When the button is pressed, the first trigger is validated (as by default, it is set to \"pulse\") and will respond to any value received at the provided address. When the button is released, the end trigger is validated in the same way, before the transition returns to the initial `Sync`. ## Consecutive toggles The section inside the loop can contain more than one interval. Expanding on the prior example, switching between an idle state and an interval, a similar structure could enclose two intervals. This switch also requires an extra trigger. ![Consecutive switch]({{ site.img }}/reference/common-practices/consecutive.gif \"Consecutive switch\") With the default \"Pulse\" operators to validate each trigger, this structure will return to the idle state after each transition. To avoid this extra step and make sure that the first interval executes every time the button's value is true and that the second executes every time it is false, the expression for the trigger has to be modified. By setting both the start and end triggers to only respond when the value is true, they can be validated in a row, skipping the idle state after the transition.Â  ![Consecutive 2 stages switch]({{ site.img }}/reference/common-practices/seq2Stage.gif \"Consecutive 2 steps switch\") A better way of achieving the same result would be to rely on a [sub-scenario to isolate the loop]({{ site.baseurl }}/common-practices/1-looping.html#nested-loops). Since the first trigger is only needed to control the very first execution of the loop, it can be validated once to enter the sub-scenario and omitted in the actual toggle structure. The trigger at the end of the sub-scenario is left \"never\" valid to allow as many repetitions as needed. ![Consecutive switch isolated]({{ site.img }}/reference/common-practices/seqIsolate.gif \"Consecutive switch isolated\") It may be preferable to switch at every press of the button, instead of having to hold for the first interval and let go for the second. Adding a minimum duration on each of the toggled intervals ensures that the value of the button can go back to false without validating the next trigger. This method also protects the switch from accidental \"double taps\". ![Tap once to switch]({{ site.img }}/reference/common-practices/tapToSwitch.gif \"Tap once to switch\") ## Parallel switches Consecutive switches shown above can sequence an arbitrary number of intervals, but only in the same order every time. To enable switching as well as reordering, we can rely on conditional branches. Let's first create another device for control. For this example we will add a [[mapper device]] by copying and pasting the script below. We will name it \"Structure\". ```qml import Ossia 1.0 as Ossia Ossia.Mapper { function createTree() { return [ { name: \"Branch\", type: Ossia.Type.Int, write: function(v) { return v.value; } } ]; } } ``` ![Structure mapper]({{ site.img }}/reference/common-practices/structureMapper.gif \"Structure mapper\") Parallel branches start from the same `Sync`. Syncing them at the end too will also make them responsive to the same trigger and allow us to only set up one transition to loop the entire structure. ![Parallel sync]({{ site.img }}/reference/common-practices/parallelSync.gif \"Parallel sync\") To add conditions for each start state of parallel intervals, they have to be split into individual events with the \"Split condition\" function. The state connecting the transition back to the initial `Sync` does not require a condition. Finally, a trigger on the end `Sync` can reset the loop with every new value set in the mapper. ![Conditions]({{ site.img }}/reference/common-practices/conditions.gif \"Conditions\") It is now possible to switch between parallel intervals when setting a value to the \"Branch\" parameter. To control the start of the structure when played the first time, we have to avoid adding a trigger to the start sync of the loop. It would add an idle state as we experienced before and skip the evaluation of every other value. Instead we can isolate this switch from its initial trigger with another transition, similar to our solution to [looping parallel branches]({{ site.baseurl }}/common-practices/1-looping.html#loop-branches). ![Isolated conditions]({{ site.img }}/reference/common-practices/isolateConditions.gif \"Isolated conditions\") ",
    "url": "https://ossia.io/score-docs/common-practices/2-switches.html",
    "relUrl": "/common-practices/2-switches.html"
  },"2": {
    "doc": "2D Spline",
    "title": "2D Spline",
    "content": "# 2D Spline (X-Y automation) ![2D spline]({{ site.img }}/reference/processes/2Dspline.png \"2D spline example\") It is possible to use math formulas to generate a specific spline. To do so, right-click on a spline, and select `Generate curve` in the menu. The available variable is `t`. It is evaluated between 0 and 1. The syntax uses ExprTK (see [ExprTK support reference page]({{ site.baseurl }}/processes/exprtk.html \"ExprTK ref page\")). Here are some useful examples: ## Circle ```matlab var tp := 2 * PI * t; x := tp * cos(tp); y := tp * sin(tp); ``` ## Spiral ```matlab var tp := 2 * PI * t; x := tp * cos(tp); y := tp * sin(tp); ``` ## Expanding spiral ```matlab var tp := 2 * PI * t; x := 0.04 * exp(0.3 * tp) * cos(tp); y := 0.04 * exp(0.3 * tp) * sin(tp); ``` ## Lissajoux ```matlab var tp := 2 * PI * t; x := cos(3 * tp); y := sin(2 * tp); ``` ```matlab var tp := 2 * PI * t; x := cos(5 * tp); y := sin(3 * tp); ``` ## Hypotrochroids ### Star 1 ```matlab var tp := 6 * PI * t; var a := 5; var b := 3; var d := 3; x := (a - b) * cos(tp) + d * cos(tp * (a - b) / b); y := (a - b) * sin(tp) - d * sin(tp * (a - b) / b); ``` ### Star 2 ```matlab var tp := 6 * PI * t; var a := 5; var b := 3; var d := 5; x := (a - b) * cos(tp) + d * cos(tp * (a - b) / b); y := (a - b) * sin(tp) - d * sin(tp * (a - b) / b); ``` ## Others See [https://en.wikipedia.org/wiki/Parametric_equation](https://en.wikipedia.org/wiki/Parametric_equation \"Parametric equation Wikipedia page\") for inspiration. ```matlab var tp := 2 * PI * t; var a := 4; var b := 1; var c := 4; var d := 1; var j := 3; var k := 3; x := cos(a * tp) - pow(cos(b * tp), j); y := sin(c * tp) - pow(sin(d * tp), k); ``` ```matlab var tp := 2 * PI * t; var a := 80; var b := 1; var c := 80; var d := 1; var j := 3; var k := 3; x := cos(a * tp) - pow(cos(b * tp), j); y := sin(c * tp) - pow(sin(d * tp), k); ``` ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html",
    "relUrl": "/processes/2Dspline.html"
  },"3": {
    "doc": "Out-of-time triggering",
    "title": "Out-of-time triggering",
    "content": "# Out-of-time triggering By default, `score` works as a time-line: time flows from the start to the end of the score. As mentioned by [[non-linear timelines|the quick start guide]], the time-line can be made non-linear by adding triggers and graph connections. It is possible to go one step further, by entirely removing parts of the score from the \"main\" timeline and triggering them at any point in time: for instance in response to an OSC message, by clicking, ... ## Creating an out-of-time score To remove a part of the score from the time-line, simply make sure that it isn't connected to the start of the time-line: ![Disconnected interval]({{ site.img }}/common-practices/out-of-time-1.png) When playing the score, this interval now won't run anymore: ![Disconnected interval not playing]({{ site.img }}/common-practices/out-of-time-2.png) Some *score* users use that mechanism as a sand-box to try various behaviours. Now, to play this part of the score, we have to tell *score* what is going to trigger it. Thus, we have to add a [trigger]({{ site.baseurl }}/processes/scenario.html#triggers) to the start of the interval: ![A trigger]({{ site.img }}/common-practices/out-of-time-trigger.png) Then, select the trigger, go to the inspector and enable the \"Start on play\" which will make the trigger available for triggering when the score starts, with the right button: ![Trigger inspector]({{ site.img }}/common-practices/out-of-time-inspector.png) ## Re-triggering The left button in the inspector is used to control the re-triggering behaviour. If left unchecked, re-triggering the trigger will stop the sub-score that follows it. It will need another event to start again. If checked, it will restart automatically from the beginning every time the trigger is triggered. ",
    "url": "https://ossia.io/score-docs/common-practices/3-out-of-time.html",
    "relUrl": "/common-practices/3-out-of-time.html"
  },"4": {
    "doc": "Audio techniques",
    "title": "Audio techniques",
    "content": "# Audio techniques ## Playing a sound file To play a [[Soundfiles|sound file]], drag'n'drop it in the score, from the library, or from your operating system. If you don't hear a sound, check that : * The time cursor is increasing (if not, that means that the sound card is not [properly configured]({{ site.baseurl }}/faq/doesnotwork.html)). * The sound file is linked to the beginning of the score via an [interval]({{ site.baseurl }}/processes/scenario.html#intervals). It should look like this: ![Sound file playing]({{ site.img }}/common-practices/audio-1.png) ## Applying an effect To apply an effect to a sound file: 1. Drop it from the process library to the sound file interval. 2. Connect a cable from the audio file output to the effect input. Now the sound will be routed entirely through the effect. 3. Add more effects in the same manner, by connecting the output of the previous effects to the input of the following ones ! ## Applying an effect to multiple audio files To apply an effect to multiple files, it would be possible but unwieldy to connect a cable from each file to the audio effect. Instead, we can group them in a single [scenario]({{ site.baseurl }}/processes/scenario.html), and rout the scenario's output to the audio effects: ![Grouping]({{ site.img }}/common-practices/audio-group.png) ## Fade-ins and fade-outs Every audio outlet has a \"gain\" sub-outlet which can be used to perform fades. 1. Press the audio outlet. 2. Right-click on the \"gain\" port. 3. Select \"Create automation\". The created automation can then be used to adjust the volume of that output in time. ![Fading]({{ site.img }}/common-practices/audio-fade.png) ## Analysing an audio signal *score* provides a simple envelope analyzer. Combined with the signal display process, this allows to visualize a signal in the time-line. 1. Add an envelope process (Audio > Envelope). 2. Add a signal display process (Monitoring > Signal display) 3. Route the audio output to the input of the envelope process. > This means that the entire audio is routed to the envelope process, and thus won't be heard anymore. To prevent this, > check \"Propagate\" in the audio outlet inspector. 4. Route the envelope output to the signal display input. The first output measures RMS, the second measures peak values. 5. If the signal is too low, add a Custom Mapping process between the envelope and the signal display, in order to multiply it by some factor meaningful for your signal. ![Envelope]({{ site.img }}/common-practices/audio-envelope.png) ## Sound spatialization *score* allows arbitrary numbers of audio channels to go through its ports. This makes it possible to use it for instance with large speaker arrays, domes, etc. A simple and efficient 2D spatialization algorithm is provided with the [[Faust]] `spat` preset (which uses the spatialization method devised by Laurent Pottier). By default, it will spatialize a mono source on a 8-channel circular loudspeaker array. ![Spatialization]({{ site.img }}/common-practices/audio-spat.png) It is possible to edit the Faust script, to change the number of loudspeakers: 1. Press the \"Window\" icon next to the Faust process name, to open its editor. 2. Edit the following line with the number of wanted loudspeakers instead of `8`: ```faust process = vgroup(\"Spatializer 1x8\", sp.spat(8, angle, distance)); ``` 3. Press \"Compile\". The Faust process will be compiled and updated automatically. ## Using live audio input To use a live audio input in a part of the score, follow these steps: 1. Set-up the [[audio device]] in the device explorer. 2. Drag'n'drop the input address to use as an input of a sound effect. In the following example, a stereo bus receiving a stereo guitar signal has been created. It is sent to a reverb. ## Applying global audio effects As mentioned in [[audio-routing]], mixing is by default hierarchical: objects mix their output in their parent object. In general, most scores will be built around a top-level scenario, which will contain all the structures: ![Example of score]({{ site.img }}/common-practices/audio-example-1.png) This scenario is no exception to the rule: if you scroll at the bottom of the score, you'll notice it comes with an output audio port, too. In this example, we reduce its slots's height so that it is visible: ![Smaller slot]({{ site.img }}/common-practices/audio-example-slot.png) It is then possible to connect the output of this scenario to another process, to apply a global audio filter: ![Scenario audio output]({{ site.img }}/common-practices/audio-example-global.png) If complex filtering is necessary, it is of course possible to switch into the nodal view to create advanced effect routings: ![Modular scenario view]({{ site.img }}/common-practices/audio-example-modular.png) ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html",
    "relUrl": "/common-practices/4-audio.html"
  },"5": {
    "doc": "Video techniques",
    "title": "Video techniques",
    "content": "# Video techniques ## Playing videos See the quick start guide: [[Working with video]]. ## Fades ## Making audio-reactive visuals ",
    "url": "https://ossia.io/score-docs/common-practices/5-video.html",
    "relUrl": "/common-practices/5-video.html"
  },"6": {
    "doc": "Scenes",
    "title": "Scenes",
    "content": "# Scenes Scenes are a common pattern in intermedia creation: you want to split a show for instance in a sequence of acts, chapters, etc. To achieve this in *score*, the general principle is to have sequences of intervals, each containing a sub-scenario. ## Structuring a score for dynamic scenes To go from one scene to the next dynamically by responding to an interaction, it is sufficient to add triggers. It is also possible to use the Play from here tool to transport the timeline to a specific point. Don't forget to label your scenes in the inspector to make the score easier to read: ![Splitting a score in scenes]({{ site.img }}/common-practices/scenes-1.png) ## Working with scenes To work on a specific scene, simply go in \"full view\". That is, either double-click on the interval header, or press the full view button in the interval inspector. If you have a lot of scenes, you can use the object finder (at the top-right) to find your scene by name or label: ",
    "url": "https://ossia.io/score-docs/common-practices/6-scenes.html",
    "relUrl": "/common-practices/6-scenes.html"
  },"7": {
    "doc": "Release build",
    "title": "Release build",
    "content": "# Build This page describes how to build score on various operating systems. **Dear packagers: here are specific build instructions to make packages for Linux/BSD/... : [Packaging score for Linux]({{ site.baseurl }}/development/build/packaging.html)**. ## Dependencies To build, you will need the following dependencies : * [Qt 5](http://www.qt.io/) (>= 5.12) * [CMake](https://cmake.org/) (>= 3.15) * [Boost](http://www.boost.org/) (automatically downloaded) * (optional) FFMPEG (http://www.ffmpeg.org) (>= 3.3) * A **recursive** clone of the score repository : `git clone --recursive https://github.com/ossia/score`. The easiest way to get most dependencies in a prebuilt form is by [downloading our SDK for your platform](https://github.com/ossia/sdk/releases). **Important:** do not use the source releases produced by GitHub : they do not have the submodules and compiling with them won't work. Your compiler need to be recent; supported compilers are: * gcc >= 8 * clang >= 8 * Xcode >= 11 * Visual Studio 2019 (the very latest version !) What does **not** work : - GCC ` in `qtbase/src/plugins/platforms/android/androidjniinput.cpp`. Configure and build Qt5 : ../qt5/configure -opensource -confirm-license -xplatform 'android-clang-libc++' -nomake tests -nomake examples -android-ndk /opt/android-ndk-r15b -android-sdk /opt/android/sdk -android-arch armeabi-v7a -no-warnings-are-errors -opengl es2 -opengles3 -android-ndk-platform android-22 -prefix /opt/qt-android make -j8 make install Build the player library : cd ~/build cmake ~/score -DCMAKE_TOOLCHAIN_FILE=~/score/API/CMake/android_toolchain.cmake -DCMAKE_PREFIX_PATH=/opt/qt-android/lib/cmake/Qt5 -DISCORE_CONFIGURATION=android-debug -DISCORE_PLAYER=1 -Wno-dev -DOSSIA_PROTOCOL_MIDI=0 Put the library in the correct folder : mkdir -p /opt/qt-android/qml/Ossia/ ln -s ~/score/API/ossia/ossia-qml/Ossia/*.qml /opt/qt-android/qml/Ossia/ cp ~/score/API/ossia/ossia-qml/Ossia/qmldir /opt/qt-android/qml/Ossia/ ln -s ~/build/libiscore_player_plugin.so /opt/qt-android/qml/Ossia/ Change the name of the library in the qmldir (iscore_player_plugin instead of ossia) To run with QtCreator, add the following library in the android build : /opt/android-ndk-r14b/sources/cxx-stl/llvm-libc++/libs/armeabi-v7a/libc++_shared.so (adapt the architecture, paths, etc... for your phone / tablet) ## Sanitization clang-tidy -p ~/iscore-tidy/compile_commands.json base/**/*.cpp --header-filter=base/ ",
    "url": "https://ossia.io/score-docs/development/build/release.html",
    "relUrl": "/development/build/release.html"
  },"8": {
    "doc": "Hacking",
    "title": "Hacking",
    "content": "# Quickstart This page presents how to start developing things on ossia score. We recommend heavily to use QtCreator as IDE to do so, or at least an IDE with native support for CMake. - [For Windows](#windows-with-visual-studio) - [For macOS](#macos) - [For various Linux distros](#arch-linux) # System dependencies Ensure that you have the latest version of Qt, boost, and your C++ compiler installed. *Note* : to ensure a very fast build time, it is recommended to use clang as compiler and ninja for building, on every platform. Additionally, on Linux and Windows `lld` can be used as a linker. It is quite faster than `GNU ld` and `gold`. At the time of this writing, this means : | Software | Version |----------|---------------------------------| Compiler | clang 11 or gcc 10 or msvc 2019 | Qt | 5.15 (Qt6 is not supported yet) | Boost | 1.75 | CMake | 3.20 | However, to get a complete build with support for more features, more is needed : | Software | Version |---------------|---------| FFMPEG | 4.x | # Required for sound playback | LLVM | 9.x | # Required for Faust support | OpenSSL | 1.1.x | # Required to connect to wss / https | Faust | Latest | # Required to load Faust plug-ins | suil, lilv | Latest | # Required to load LV2 plug-ins | PortAudio | Latest | # Required to playback sound using Coreaudio, ASIO, ALSA, Pulseaudio... | JACK2 | Latest | # Required to playback sound using JACK | SDL2 | Latest | # Required to have gamepad support | qt 5.15 | Latest | # Required for the GFX addon | qtshadertools | Latest | # Required for the GFX addon They can be downloaded either from here for a pre-built set of packages : https://github.com/ossia/sdk/releases Or you can install them with your package manager of choice - see the packages for each platform at the end of this document. # Useful documentation - (Using) CMake : https://cliutils.gitlab.io/modern-cmake/chapters/intro/running.html - (Writing) CMake : https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html - Qt : https://doc.qt.io/qt-5/gettingstarted.html - Qt Creator : https://doc.qt.io/qtcreator/index.html # Building on the command line First get a recursive clone of the repository : $ git clone --recursive -j16 https://github.com/ossia/score The preferred way to build when hacking on the software is with [cninja](https://github.com/jcelerier/cninja): cninja ~/path/to/score developer Alternatively, one can build with CMake. Pass the following options to `cmake` to ensure maximal build speed: (note that the instructions later on this page may not be entirely up-to-date) -GNinja -DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++ -DCMAKE_SHARED_LINKER_FLAGS=\"-fuse-ld=lld\" -DCMAKE_EXE_LINKER_FLAGS=\"-fuse-ld=lld\" -DCMAKE_BUILD_TYPE=Debug -DSCORE_PCH=1 -DSCORE_DYNAMIC_PLUGINS=1 For instance, for generating the build files on Ubuntu, Debian or Linux Mint, that gives : cmake /path/to/score \\ -GNinja \\ -DCMAKE_C_COMPILER=/usr/bin/clang \\ -DCMAKE_CXX_COMPILER=/usr/bin/clang++ \\ -DCMAKE_SHARED_LINKER_FLAGS=\"-fuse-ld=lld\" \\ -DCMAKE_EXE_LINKER_FLAGS=\"-fuse-ld=lld\" \\ -DCMAKE_BUILD_TYPE=Debug \\ -DSCORE_PCH=1 \\ -DSCORE_DYNAMIC_PLUGINS=1 *Note : * Run the `cmake` command in a separate build folder, especially not in the source directory of score ! If you are not using your distribution's Qt version because it's too old, pass the path to a recent version with, for instance, -DCMAKE_PREFIX_PATH=/home/yourname/Qt/5.15.3/gcc_64 The path must contain a `lib` folder in which CMake is going to look for Qt. Once CMake has ran successfully, do : cmake --build . To be safe, you should have at least 15 gigabytes free on your hard drive before starting a build. # Building with Qt Creator Refer to this video : https://www.youtube.com/watch?v=LSifHFbuky0 # Quick scripts to get started ## Arch Linux ``` pacman -S git cmake ninja clang lld boost qt5-base qt5-imageformats qt5-websockets qt5-quickcontrols2 qt5-serialport qt5-declarative qt5-tools ffmpeg portaudio jack lv2 suil lilv sdl2 # Clone the code git clone --recursive -j16 https://github.com/ossia/score cd score # Build mkdir build cd build CC=clang CXX=clang++ cmake .. -GNinja -DCMAKE_BUILD_TYPE=Debug -DSCORE_PCH=1 -DSCORE_DYNAMIC_PLUGINS=1 ninja # Run ./ossia-score ``` ## Ubuntu 20.10, 20.04, 19.10, 19.04, 18.10, 18.04 ``` # Install dependencies snap install cmake --edge --classic apt update apt -y install clang lld build-essential libavdevice-dev libavformat-dev libswresample-dev ninja-build portaudio19-dev llvm-dev libclang-dev liblilv-dev libsuil-dev git mesa-common-dev # If you want to use the latest Qt which fixes a lot of bugs present in Debian's old version apt -y install python3-pip python3 p7zip-full python3 -m pip install aqtinstall python3 -m aqt install --outputdir ~/Qt 5.15.1 linux desktop # Else use that: apt -y install qtbase5-dev qtdeclarative5-dev qtbase5-private-dev qtdeclarative5-private-dev libqt5websockets5-dev # Clone the code git clone --recursive -j16 https://github.com/ossia/score cd score # Build mkdir build cd build CC=clang CXX=clang++ cmake .. -DCMAKE_PREFIX_PATH=~/Qt/5.15.1/gcc_64 -GNinja -DCMAKE_BUILD_TYPE=Debug -DSCORE_PCH=1 -DSCORE_DYNAMIC_PLUGINS=1 ninja # Run ./run.sh ``` ## Debian stable (also derivatives such as LibraZiK) ``` # Install dependencies apt update apt -y install build-essential libboost-dev libavdevice-dev libavformat-dev libswresample-dev cmake ninja-build portaudio19-dev git mesa-common-dev # If you want to use the latest Qt which fixes a lot of bugs present in Debian's old version apt -y install python3-pip python3 p7zip-full python3 -m pip install aqtinstall python3 -m aqt install --outputdir ~/Qt 5.15.1 linux desktop # Else use that: apt -y install qtbase5-dev qtdeclarative5-dev qtbase5-private-dev qtdeclarative5-private-dev libqt5websockets5-dev # Also useful but not mandatory (support for LV2, wiimotes, serial port, etc...): apt -y install llvm-dev libbluetooth-dev libqt5serialport5-dev libqt5websockets5-dev libfftw3-dev liblilv-dev libsuil-dev # Clone the code git clone --recursive -j16 https://github.com/ossia/score cd score # Build mkdir build cd build # The line with PREFIX is only necessary if you used the latest Qt cmake .. \\ -DCMAKE_PREFIX_PATH=~/Qt/5.15.1/gcc_64 \\ -GNinja -DCMAKE_BUILD_TYPE=Debug -DSCORE_PCH=1 -DSCORE_DYNAMIC_PLUGINS=1 ninja # Run ./run.sh ``` ## Fedora ``` # Install dependencies # RPMFusion repos are required dnf install https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm dnf install https://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm dnf install cmake clang lld ffmpeg-devel llvm-devel portaudio-devel lilv-devel suil-devel ninja-build git qt5-qtbase-devel qt5-qtsvg-devel qt5-qttools-devel qt5-qtserialport-devel qt5-qtwebsockets-devel qt5-qtdeclarative-devel qt5-qtquickcontrols2-devel # Clone the code git clone --recursive -j16 https://github.com/ossia/score cd score # Build mkdir build cd build CC=clang CXX=clang++ cmake .. -GNinja -DCMAKE_BUILD_TYPE=Debug -DSCORE_PCH=1 -DSCORE_DYNAMIC_PLUGINS=1 ninja # Run ./run.sh ``` ## OpenSuse Tumbleweed ``` # Install dependencies zypper install libqt5-qtbase-devel cmake clang ninja boost-devel lld llvm-devel libjack-devel portaudio-devel lv2-devel liblilv-0-devel suil-devel libSDL2-devel libqt5-qtdeclarative-devel libqt5-qtwebsockets-devel libqt5-qttools libqt5-qtserialport-devel libqt5-qtquickcontrols2 libqt5-qtimageformats-devel ffmpeg-4-libavcodec-devel ffmpeg-4-libavdevice-devel ffmpeg-4-libavfilter-devel ffmpeg-4-libavformat-devel ffmpeg-4-libswresample-devel # Clone the code git clone --recursive -j16 https://github.com/ossia/score cd score # Build mkdir build cd build CC=clang CXX=clang++ cmake .. -GNinja -DCMAKE_BUILD_TYPE=Debug -DSCORE_PCH=1 -DSCORE_DYNAMIC_PLUGINS=1 ninja # Run ./run.sh ``` ## macOS First install XCode and [Homebrew](https://brew.sh). Then : ``` # Install dependencies brew install git qt5 ninja cmake ffmpeg portaudio boost # Clone the code git clone --recursive -j16 https://github.com/ossia/score cd score # Build mkdir build cd build cmake ~/score -DCMAKE_PREFIX_PATH=/usr/local/Cellar/qt -GNinja -DCMAKE_BUILD_TYPE=Debug -DSCORE_PCH=1 -DSCORE_DYNAMIC_PLUGINS=1 ninja # Run ./score ``` ## Windows (with Visual Studio) First install: * The latest version of Visual Studio 2019 (16.10 as of July 2021) * [git](https://gitforwindows.org/) * [CMake](https://cmake.org/) * [Python](https://www.python.org) * Take a few seconds to contemplate the easiness of building on the above Unix platforms * Extract https://github.com/ossia/sdk/releases/download/sdk14/win-audio-sdk-msvc.zip in your `c:\\` so that the folders once extracted look like `c:\\score-sdk-msvc\\portaudio` and `c:\\score-sdk-msvc\\ffmpeg` Run a `x64 Native Tools Command Prompt for VS 2019`: ![Screenshot](https://imgur.com/chDaR6J) In the command prompt, install Qt: (Assuming your development environment is in a `c:\\dev` folder) ``` cd c:\\dev # Install dependencies ## Qt pip install aqtinstall aqt install --outputdir c:\\Qt 5.15.2 windows desktop win64_msvc2019_64 # Build cmake ../score -DCMAKE_PREFIX_PATH=\"c:/Qt/5.15.2/msvc2019_64\" -DOSSIA_SDK=\"c:/score-sdk-msvc\" -DSCORE_PCH=1 -DCMAKE_INSTALL_PREFIX=installed -DCMAKE_BUILD_TYPE=Release cmake --build . --config Release cmake --build . --config Release --target install # Run cd installed score.exe ``` ## Windows (with MSYS2) First download [the MinGW SDK](https://github.com/ossia/sdk/releases/download/sdk21/sdk-mingw.7z) and extract it in your `c:\\` (the folder should look like `c:\\ossia-sdk\\ffmpeg`) Then, in a mingw-w64 terminal (not an MSYS terminal, this is very important ! if in doubt, run `c:\\msys64\\mingw64.exe`): ``` # Install dependencies pacman -S mingw-w64-x86_64-cmake mingw-w64-x86_64-ninja # Build cmake ../score \\ -GNinja \\ -DCMAKE_C_COMPILER=\"c:/ossia-sdk/llvm/bin/clang.exe\" \\ -DCMAKE_CXX_COMPILER=\"c:/ossia-sdk/llvm/bin/clang++.exe\" \\ -DOSSIA_SDK=\"c:/ossia-sdk\" \\ -DSCORE_PCH=1 \\ -DOSSIA_USE_FAST_LINKER=1 \\ -DCMAKE_BUILD_TYPE=Debug \\ -DCMAKE_INSTALL_PREFIX=installed cmake --build . --config Release cmake --build . --config Release --target install # Run cd installed score.exe ``` ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html",
    "relUrl": "/development/build/hacking.html"
  },"9": {
    "doc": "Packaging",
    "title": "Packaging",
    "content": "# General information Score has many build options, modules, etc... but there is one canonical way to build a release tailored for Unix distributions. **Please** use the package versions provided with score / libossia as much as possible and not the distribution-provided packages, else we get bug reports because the version of TBB / PortAudio / ... of $DISTRO has known problems. In particular RtMidi and oscpack have been more or less entirely rewritten. If you don't want to, then it's better to let the users use the AppImage because those are known to be working. If your distro has a PortAudio package, please ensure that its PortAudio version is not linking against JACK, because else it can cause hangs (e.g. in Debian, Ubuntu). If it does, then please ensure that score does not link against PortAudio. An example of package is the one provided in the ArchLinux AUR : https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=ossia-score # Dependencies * CMake (>= 3.9) * Qt (>= 5.12) * Boost (whatever is the latest version, at least 1.68) * FFMPEG (libavcodec, etc., at least FFMPEG 3) # Building a release The procedure is straightforward: ```bash # Configure step cmake -Wno-dev \\ -DCMAKE_BUILD_TYPE=Release \\ -DCMAKE_UNITY_BUILD=1 \\ -DDEPLOYMENT_BUILD=1 \\ -DCMAKE_SKIP_RPATH=ON \\ -DCMAKE_INSTALL_PREFIX=\"/usr\" \\ \"srcdir\" # Build step # Just running make is possible but will be much slower. cmake --build . # adding -- -j4 at least will greatly increase build speed # Install step # do **not** just run make install, else score will install a lot of unneeded headers (boost, etc). cmake -DCMAKE_INSTALL_DO_STRIP=1 -DCOMPONENT=OssiaScore -P cmake_install.cmake ``` ### Important note Due to a bug not fixed in mainline LLVM yet, we recommend disabling the JIT plug-in which may cause crashes (will be fixed in LLVM-12 ; LLVM-11 and LLVM-10 won't work). Add the following to the CMake invocation: -DSCORE_DISABLED_PLUGINS=\"score-plugin-jit\" ",
    "url": "https://ossia.io/score-docs/development/build/packaging.html",
    "relUrl": "/development/build/packaging.html"
  },"10": {
    "doc": "Architecture",
    "title": "Architecture",
    "content": "# Score API documentation The API documentation is [available at the following link](https://ossia.io/score-api-docs/). # UML model A draft UML model of the software is available in the git repository, [at the following link](https://github.com/ossia/score/blob/master/docs/Models/score.qmodel). It can be opened with Qt Creator. ",
    "url": "https://ossia.io/score-docs/development/architecture.html",
    "relUrl": "/development/architecture.html"
  },"11": {
    "doc": "Art-Net device",
    "title": "Art-Net device",
    "content": "# Art-Net device ![Device setup window]({{ site.img }}/reference/devices/artnet/artnet-1.png \"score device setup\") It is possible to communicate through DMX with ossia score, in order to control and automate light fixtures. The [user library]({{ site.baseurl }}/in-depth/library.html) contains a built-in fixture library that can be added: ![Device setup window]({{ site.img }}/reference/devices/artnet/artnet-2.png \"score device setup\") If no fixtures are added, then the device will instead provide the 512 raw DMX channels. Else, each fixture will appear as a node of the device. ",
    "url": "https://ossia.io/score-docs/devices/artnet-device.html",
    "relUrl": "/devices/artnet-device.html"
  },"12": {
    "doc": "Audio device",
    "title": "Audio device",
    "content": "# Audio device This device allows to expose the physical inputs and outputs of the sound card as device tree nodes, which can then be used at any place in the score to route a part of the score to a specific sound card output for instance. ![Device setup window]({{ site.img }}/reference/devices/audio/audio-0.png) ## Audio parameters It is possible to set a float value between 0 and 1 on the audio parameters, for instance to automate the global volume of a given output. Multiple processes sending audio to the same parameter will be summed. ## Device tree For a sound card with two mono inputs and outputs, creating the device would look like this: ![Device setup window]({{ site.img }}/reference/devices/audio/audio-1.png) * The address `audio:/out/0` will refer to the first channel on the sound card. * The addresses `audio:/in/main` and `audio:/out/main` respectively refer to the entirety of the available channels. * In a score, the root interval is routed to `audio:/out/main`. * The volume control at the bottom of the user interface is a shortcut to control `audio:/out/main`'s volume. ## Adding busses It is possible to create busses, for instance to create stereo pairs. To do so, just add a child to the device : ### Physical busses ![Device setup window]({{ site.img }}/reference/devices/audio/audio-2.png) The matrix shows which channels from the soundcard will be mapped to which channels of the port, in ascending order. For instance, the above screenshot creates a bus which will send its first channel to the second output of the soundcard, and its second channel to the fourth output of the soundcard. ### Virtual busses These are abstract busses that can be used for communication within score (for instance to send the output of a set of processes to another process, to make e.g. an aux track). ",
    "url": "https://ossia.io/score-docs/devices/audio-device.html",
    "relUrl": "/devices/audio-device.html"
  },"13": {
    "doc": "Audio plugins",
    "title": "Audio plugins",
    "content": "# Standard plug-in formats vstpuppet rescanning plug-ins ## VST support ## VST3 support ## LV2 support # Advanced plug-in and extensions ## Faust support ## Pure Data support ## C++ JIT ",
    "url": "https://ossia.io/score-docs/processes/audio-plugins.html",
    "relUrl": "/processes/audio-plugins.html"
  },"14": {
    "doc": "Audio routing",
    "title": "Audio routing",
    "content": "# Audio routing * There is an implicit routing from child process to parent interval, and from interval to parent scenario, recursively up to the top of the score. * The audio output of the top interval is routed by default to the main stereo output of the audio interface defined in Audio Preferences. * When connecting an audio outlet to another audio inlet, propagation is removed. This means that the dry output of the source process will not be mixed in its parent interval. This can be toggled by selecting the port, in the [[inspector]]. ",
    "url": "https://ossia.io/score-docs/in-depth/audio-routing.html",
    "relUrl": "/in-depth/audio-routing.html"
  },"15": {
    "doc": "Audio utilities",
    "title": "Audio utilities",
    "content": "# Gain # Envelope gain # Metronome # Stereo merger ",
    "url": "https://ossia.io/score-docs/processes/audio-utilities.html",
    "relUrl": "/processes/audio-utilities.html"
  },"16": {
    "doc": "Audio looper",
    "title": "Audio looper",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/audio-looper.html",
    "relUrl": "/processes/audio-looper.html"
  },"17": {
    "doc": "Automation (float)",
    "title": "Automation (float)",
    "content": "# Automation (float) ![Automation Float]({{ site.img }}/reference/processes/automation_float.png) The `Automation (float)` process allows to control single value parameter using a breakpoints function. ## Basic editing ### Create new points on curve Multiple points can be added on an automation. To add a point, double-click in the automation slot to create a point under the mouse cursor. ![Automation create point]({{ site.img }}/reference/processes/automation_float/create-points.gif \"Create new points\") You can also create a new point using {% include shortcut.html content=\"Ctrl+click\" %} in the automation's slot. ### Remove points from curve To delete a point from an automation, click on a point to select it, then from its contextual menu select `Remove`. ![Automation remove point]({{ site.img }}/reference/processes/automation_float/remove-points.png \"Create new points\") > Multiple points and attached segments can be selected and removed at once using the `Remove` contextual menu entry. ### Edit points To edit a point value of position in time, select it using the mouse and move it along the `x` axis to adjust in position in time, or along the `y` axis to adjust its value. You will note that when selecting a point, its value gets displayed next to the mouse cursor For fine control, you can also use the dedicated number boxes from the inspector. Click on a point to select it and display its inspector then use the `value` number box to adjust to the desired value. ![Automation adjusting point]({{ site.img }}/reference/processes/automation_float/adjusting-points.png \"Create new points\") ### Adjust segment's curve `Power` type segments (default) can be added a curve factor. To do so, click a segment and use {% include shortcut.html content=\"Shift+Drag\" %}. Dragging the curve upward add a log-like curvature to the segment, while dragging downward add a exp-like curvature. ![Adjusting curve]({{ site.img }}/reference/processes/automation_float/adjusting-curve.gif) ## Segment shapes Segments between two points can be set to various predefined shapes. To do so, click a segment and from its contextual menu, choose the desired segment shape in the `Type` category. ![Segment shapes]({{ site.img }}/reference/processes/automation_float/segment-shapes.png) Shapes include: - `Power` (default) - `Linear` (a slightly optimized version of `Power` with zero curve factor) - Standard Easing curves | backIn | quadraticIn | quarticIn | sineIn | exponentialIn | backOut | quadraticOut | quarticOut | sineOut | exponentialOut | backInOut | quadraticInOut| quarticInOut | sineInOut | exponentialInOut | | | | bounceIn | cubicIn | quinticIn | circularIn | elasticIn | bounceOut | cubicOut | quinticOut | circularOut | elasticOut | bounceInOut | cubicInOut | quinticInOut | circularInOut | elasticInOut | | | | PerlinInOut | | | ## Freehand function Automation's function can be hand-drawn using {% include shortcut.html content=\"Alt+Drag\" %} in Automation editor. Drawn function will get optimized and transformed onto a beak-point function on mouse release so you can edit various points individually. ![Freehand curve]({{ site.img }}/reference/processes/automation_float/freehand.gif) ## Advanced edits ### Lock between points By default, moving a point in the automation is limited horizontally by previous and next points' position in automation. This can be turned on and off using the `Lock between points` option in the automation contextual menu. ![Lock between points]({{ site.img }}/reference/processes/automation_float/lock-between-points-menu.png) When off, points can be freely moved along the whole automation's slot. ![Locked between points]({{ site.img }}/reference/processes/automation_float/locked-between-points.gif) ![Unocked between points]({{ site.img }}/reference/processes/automation_float/unlocked-between-points.gif) ### Suppress on overlap When `Lock between points` option is unset, crossing adjacent points can be handled in two different ways. By default, crossing an adjacent point in automation will remove this point. This can be turned off using by unsetting the option in the automation's contextual menu. ![Lock between points]({{ site.img }}/reference/processes/automation_float/suppress-on-overlap.png) When off, moved point will get inserted at its new position without removing other points in automation. ![Suppress overlapping points]({{ site.img }}/reference/processes/automation_float/unlocked-between-points.gif) ![Preserve overlapping points]({{ site.img }}/reference/processes/automation_float/dont-suppress-points.gif) ## Tween mode ",
    "url": "https://ossia.io/score-docs/processes/automation_float.html",
    "relUrl": "/processes/automation_float.html"
  },"18": {
    "doc": "Automations",
    "title": "Automations",
    "content": "# Automations Automations are a specific kind of *score* [[process]], which will change the value of a parameter in time according to a visual curve. ## Automation types - Normal, 1D automation: [[automation (float)|documented here]]. - 2D automation: [[2D Spline|documented here]]. - Color automation: [[gradient|documented here]]. ## Creating automations It is possible to create automations in various ways besides dropping an automation process from the [[library]]: * By drag'n'dropping a parameter from the [[Device explorer]] to the score. * By using the [Interpolate States]({{ site.baseurl }}/processes/scenario.html#interpolate-states) feature. * By right-clicking on a value (green) port and pressing the \"Create Automation\" button. ## Tweening Automations can be tweened: that is, instead of starting from a fixed value, the automation can instead ramp from the current value of the parameter it is automating, in order to allow for smooth transitions. Check the inspector to enable the feature. ## Units Automations can use the *ossia* [[Address system|address and unit system]]. ## Recording It is possible to [[record]] messages from external devices as automations. See also the [[preferences]] for various options concerning the way these automations are recorded. ",
    "url": "https://ossia.io/score-docs/in-depth/automations.html",
    "relUrl": "/in-depth/automations.html"
  },"19": {
    "doc": "Breaking the timeline",
    "title": "Breaking the timeline",
    "content": "# Breaking the timeline In previous steps of this Quick Start guide, we used *score* to write simple scenario use cases following a timeline-based approach pretty similar to the one found in usual DAW software. While such an approach allows to write very precise temporal developments of a scenario, it may also hit some limits in live performance situation or installation where a much more flexible approach is required. *score* offers a number of features to bridge the gap between different approaches and thus combine timeline-based workflow and cue-based workflow. One of them is the use of `trigger` points. ## Enabling triggers Introducing trigger points in your scenario allows to keep organizing things in time while allowing interactive triggering of elements: when executing the scenario, parts of the scenario starting with a `trigger` point will be put \"on hold\" until they get triggered. When triggered, following automations and states will get executed at the speed and duration specified in the scenario. To add a trigger point, simply select a state on the scenario, then from its inspector, toggle on the `trigger` icon. ![Enabling trigger]({{ site.img }}/quick-start/breaking-the-timeline/enabling-trigger.gif \"Enabling trigger\") When turning on the `trigger`, you can see a T-like icon appearing on top of the selected `state`. You can also note that a dashed line appears on top of the preceding automation slot. This indicates that the duration of the preceding automations is now undefined: preceding automations will get executed up until the trigger is, well... *triggered*. In the example above, the scenario start with a simple fade-in. Notice that it gets executed as the scenario play-head goes across the automation slot. While the scenario play-head continues its progression, you will notice though that the green progression bar at the top of the automation stops as it reaches the trigger point. Execution of the following automations is then on hold until the trigger point is triggered by a mouse click. From then, execution follow its curse until the next trigger point in the scenario. Here again, execution is put on hold until trigger point is clicked by mouse. ## Triggers remote control In the example above, we used the mouse to trigger the followup of the scenario execution. While convenient for demo purpose, you are most likely to rely on other inputs in creation situation such as some controller gear. You may use as an input for some trigger points, any parameter from your device. To set an input for a trigger point, just grab the desired parameter in the `Device explorer` and drop it on the trigger icon. ![Enabling trigger]({{ site.img }}/quick-start/breaking-the-timeline/interactive-trigger.gif \"Enabling trigger\") In the example above, we use as an input, one button of a Korg nanoKontrol [Midi controller]({{ site.baseurl }}/devices/midiin-device.html). When done, you will see in the inspector the address of the dropped parameter in the address field. > You may also drop the parameter on the address field of the trigger point inspector. When playing your scenario, part of your scenario will now get triggered as you press the dedicated button on your controller. ",
    "url": "https://ossia.io/score-docs/quick-start/breaking-the-timeline.html",
    "relUrl": "/quick-start/breaking-the-timeline.html"
  },"20": {
    "doc": "Building from source",
    "title": "Building from source",
    "content": "Depending on the reasons that landed you on this page, you may want to look at the following instructions : * If you want to package *ossia score* for a Linux distribution or something like that, please refer to [[packaging|Packaging score for Linux]]. * If you are an *user* of score and want to build the latest version, please refer to [[Release build|Creating a release build]]. * If you want to *develop* score then follow [[hacking|Hacking on score]]. ",
    "url": "https://ossia.io/score-docs/development/build-from-source.html",
    "relUrl": "/development/build-from-source.html"
  },"21": {
    "doc": "Bytebeat",
    "title": "Bytebeat",
    "content": "# What is bytebeat? - https://greggman.com/downloads/examples/html5bytebeat/html5bytebeat.html - http://nightmachines.tv/the-absolute-beginners-guide-to-coding-bytebeats.html - https://github.com/greggman/html5bytebeat - https://github.com/radavis/bytebeat - http://countercomplex.blogspot.com/2011/10/algorithmic-symphonies-from-one-line-of.html # Example ```cpp (((t>7)&t>>12))|t>>(4-(1^7&(t>>19)))|t>>7) ``` - Lots of examples here: https://www.reddit.com/r/bytebeat/comments/20km9l/cool_equations/ ",
    "url": "https://ossia.io/score-docs/processes/bytebeat.html",
    "relUrl": "/processes/bytebeat.html"
  },"22": {
    "doc": "Camera device",
    "title": "Camera device",
    "content": "## Usage Score supports using camera inputs in its VFX graph. ## Example - Brancher la camÃ©ra - Faire Add Device > Camera - La camÃ©ra devrait apparaÃ®tre dans la liste. - Ajouter un shader, par exemple Video.fs (Presets/GLSL_shaders in the user library) - Ajouter un device Window pour avoir un endroit ou lire la vidÃ©o. - Dans le shader mettre l'entrÃ©e Ã  la camera, la sortie Ã  la window. - Faire play :-) ## Informations techniques ## Utiliser les API systÃ¨me sous windows & mac Rien de spÃ©cial ? ## Utiliser V4L2 sous linux The v4l2loopback kernel module allows for a lot of useful things. ### Exemple Linux de grabbing d'Ã©cran ```bash $ sudo modprobe v4l2loopback $ ffmpeg -f x11grab -framerate 60 -video_size 3840x2160 -i :0.0+0,0 -f v4l2 /dev/video0 ``` ### Exemple Linux de forwarding de vidÃ©o ```bash $ sudo modprobe v4l2loopback $ while 1 ; do ffmpeg -re -i ./test.mp4 -f v4l2 /dev/video0 ; done ``` ",
    "url": "https://ossia.io/score-docs/devices/camera-device.html",
    "relUrl": "/devices/camera-device.html"
  },"23": {
    "doc": "Command line API",
    "title": "Command line API",
    "content": "You can launch ossia score from the command line or shell scripts with various useful options. # Command-line reference ## List of command-line options ### Getting the list of options ```bash $ ossia-score --help ``` ### Loading a score on startup: ```bash $ ossia-score filename # For example: $ ossia-score /home/oscar/my-score.score ``` ### Playing a score on startup ```bash $ ossia-score --autoplay filename # For example: $ ossia-score --autoplay /home/oscar/my-score.score ``` ### Playing a score on startup after some delay This is useful if for instance the score has audio plug-ins that take some time to load, such as orchestral plug-ins with large sound banks. ```bash $ ossia-score --autoplay filename --wait delay_in_seconds # For example: $ ossia-score --autoplay /home/oscar/my-score.score --wait 5 ``` ### Loading score without showing the GUI ```bash $ ossia-score --no-gui ``` (note: this is not very useful without specifying a file to load). ### Loading score without showing the \"do you want to restore\" pop-up dialog This is useful if you are quitting score for instance by killing the process, as score will register that as a crash, which will cause the pop-up to show up next time. ```bash $ ossia-score --no-restore ``` ### Loading score in software rendering mode ossia score uses as of v3 OpenGL for rendering the main timeline. On some old machines or machines with bad GL drivers, this can cause issues. We then recommend using that switch to launch it. ```bash $ ossia-score --no-opengl ``` ## Complete recommended command line to launch a score on startup ### On Linux: ```bash $ /usr/bin/ossia-score --no-gui --no-restore --wait 5 --autoplay \"/path/to/your/score.score\" ``` ### On macOS: ```bash $ /Applications/Score.app/Contents/MacOS/score --no-gui --no-restore --wait 5 --autoplay \"/path/to/your/score.score\" ``` ### On Windows: ```dosbatch > \"c:\\Program Files\\ossia score\\score.exe\" --no-gui --no-restore --wait 5 --autoplay \"c:\\path\\to\\your\\score.score\" ``` ## List of useful environment variables * `SCORE_DISABLE_ALSA=1`: on Linux, disables the ALSA backend. * `SCORE_DISABLE_AUDIOPLUGINS=1`: disables scanning of VST, LV2 plug-ins on startup. * `FAUST_LIB_PATH=/some/path`: can override the default path where *score* looks for Faust libraries (by default they ship with *score*). ",
    "url": "https://ossia.io/score-docs/reference/commandline.html",
    "relUrl": "/reference/commandline.html"
  },"24": {
    "doc": "Common practices",
    "title": "Common practices",
    "content": "# Common practices The following pages will guide you through recurring patterns and snippets that apply to various use-cases. Enjoy advanced scenario authoring for your intermedia creation ! {: .fs-6 .fw-300 } ",
    "url": "https://ossia.io/score-docs/common-practices",
    "relUrl": "/common-practices"
  },"25": {
    "doc": "Console",
    "title": "Console",
    "content": "## Description - Fonctions disponibles actuellement: * Ce sont les fonctions de la classe C++ [EditJsContext](https://github.com/ossia/score/blob/master/src/plugins/score-plugin-js/JS/ConsolePanel.hpp#L40) - Shortcut: {% include shortcut.html content=\"Ctrl+Shift+C\" %} ## Example ```js // Creates an OSC device named foo. Messages will be sent from score to 127.0.0.1:5678. // Score will listen to messages on port 1234. Score.createOSCDevice(\"foo\", \"127.0.0.1\", 5678, 1234); // Creates an OSC address on the device foo, named /bar/baz. It will receive color.rgba types. // All the usual ossia unit names are accessible, // as well as useful names such as the ones found in [addresses](addresses doc) Score.createAddress(\"foo:/bar/baz\", \"color.rgba\"); // Finds an object in the current score. // The name is the object name, put in the inspector var myObject = Score.find(\"the object name\"); // Creates an automation. The first argument must be a valid pointer to an interval // found by Score.find(...). Score.automate(myInterval, \"foo:/my/address\"); // Undo-redo Score.undo(); Score.redo(); // Transport Score.play(); Score.stop(); ``` ",
    "url": "https://ossia.io/score-docs/panels/console.html",
    "relUrl": "/panels/console.html"
  },"26": {
    "doc": "Control utilities",
    "title": "Control utilities",
    "content": "# Impulse metronome - A metronome synchronized to its parent interval. Will send an impulse on each beat. # Free metronome - A desynchronized metronome. That is, it can ignore the parent interval's tempo and will instead have its own unrelated tempo. It Will send an impulse on each beat (depending on the duration setting). If \"Quantify\" is set on \"Free\", then the raw frequency in Hertz will be used as tempo source. Else, the parent tempo is used. The rate can be chosen with the musical division selector. - ",
    "url": "https://ossia.io/score-docs/processes/control-utilities.html",
    "relUrl": "/processes/control-utilities.html"
  },"27": {
    "doc": "Controlling score with OSCQuery",
    "title": "Controlling score with OSCQuery",
    "content": "A score can be controlled through [[osc device|OSC]] and [[oscquery device|OSCQuery]] with the [[Local device]]. See also the WebSocket [[Remote Control|remote control protocol]]. ",
    "url": "https://ossia.io/score-docs/faq/controlling-score-with-oscquery.html",
    "relUrl": "/faq/controlling-score-with-oscquery.html"
  },"28": {
    "doc": "Control surface",
    "title": "Control surface",
    "content": "- Drop addresses on it - It's now possible to control them from the score directly through the UI when this specific process is running. ## Remote control API The control surface process provides remote control features, through the system discussed in [Remote Control]({{ site.baseurl }}/in-depth/remote.html). When such a process starts executing, the following message is sent: ```js { \"Message\": \"ControlSurfaceAdded\", \"Path\": \"/path/to/the/surface\", \"Controls\": [ ... list of control objects... ] } ``` When the process ends, the following message is sent: ```js { \"Message\": \"ControlSurfaceRemoved\", \"Path\": \"/path/to/the/surface\" } ``` ### Controls A control object defines a given control and has the following format. ```js { \"Custom\": \"The name of the control\", \"Domain\": { ... domain object ... }, \"Value\": { ... value object ... }, \"id\": 1234, // the identifier of the individual control \"uuid\": \"af2b4fc3-aecb-4c15-a5aa-1c573a239925\" // the identifier of the control kind } ``` The remote can send the following message to change a parameter in score: ```js { \"Message\": \"ControlSurface\", \"Path\": \"/path/to/the/surface\", \"id\": 1234, // the id of the individual control that changed \"Value\": { ... the value object ... } } ``` ### Value object The `Value` object has the following format: ```js { \"TYPE\": VALUE } ``` Where `TYPE` can be any of `Int`, `Float`, `Bool`, `String`, `Char`, `Vec2f`, `Vec3f`, `Vec4f`, `Tuple`, `Impulse`. For instance, valid values are: ```js { \"Float\": 1.23456 } { \"Int\": 127 } { \"String\": \"hello world\" } { \"Vec2f\": [0.5, 1.54] } { \"Bool\": true } { \"Impulse\": 1 } { \"Tuple\": [ { \"Float\": 1.234}, { \"String\": \"hello\" } ] } ``` ### Domain object The `Domain` object has the following format: ```js { \"TYPE\": { \"Min\": THE_MIN, \"Max\": THE_MAX } } ``` where `TYPE` is the same than above. The most common cases are of course Int and Float as it does not really make sense for bools, etc. Example to have a slider that goes from -10 to 100: ```js { \"Float\": { \"Min\": -10 \"Max\": 100 } } ``` It is also possible to define a domain through a set of acceptable values instead of a range: ```js { \"TYPE\": { \"Values\": [ ... array of acceptable values ...] } } ``` ",
    "url": "https://ossia.io/score-docs/processes/controlsurface.html",
    "relUrl": "/processes/controlsurface.html"
  },"29": {
    "doc": "C++ JIT",
    "title": "C++ JIT",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/cpp_jit.html",
    "relUrl": "/processes/cpp_jit.html"
  },"30": {
    "doc": "Development",
    "title": "Development",
    "content": "# *score* development manual This section of the manual gives an overview of the *score* development processes. It explains how to make a local build, create a plug-in, discusses the software architecture, etc. {: .fs-6 .fw-300 } ",
    "url": "https://ossia.io/score-docs/development",
    "relUrl": "/development"
  },"31": {
    "doc": "Devices",
    "title": "Devices",
    "content": "# Devices ## What are devices ? Devices are pieces of software or hardware used in your project to be controlled from *score* or used as input for your *score* scenario. *Score* currently support the following devices types: | OSC | Utilities | Hardware | Web | Lights | Audio | Video |:----------------------------------------------------------------|:------------------------------------------------------------|:----------------------------------------------------------------|:------------------------------------------------------------|:----------------------------------------------------------------||:----------------------------------------------------------------|:----------------------------------------------------------------| [OSCQuery]({{ site.baseurl }}/devices/oscquery-device.html) | [Mapper]({{ site.baseurl }}/devices/mapper-device.html) | [Midi in]({{ site.baseurl }}/devices/midiin-device.html) | [HTTP]({{ site.baseurl }}/devices/http-device.html)| [Artnet]({{ site.baseurl }}/devices/artnet-device.html) | [Audio]({{ site.baseurl }}/devices/audio-device.html) | [Window]({{ site.baseurl }}/devices/window-device.html) | [OSC]({{ site.baseurl }}/devices/osc-device.html) | [Local]({{ site.baseurl }}/devices/local-device.html) | [Midi out]({{ site.baseurl }}/devices/midiout-device.html) | [WS]({{ site.baseurl }}/devices/ws-device.html) |||[Camera]({{ site.baseurl }}/devices/camera-device.html) | [Minuit]({{ site.baseurl }}/devices/minuit-device.html) | [Serial]({{ site.baseurl }}/devices/serial-device.html) | | | [Joystick]({{ site.baseurl }}/devices/joystick-device.html) | | | [Wiimote]({{ site.baseurl }}/devices/wiimote-device.html) | ## Setting up devices From *score* main window, right-click in the `Device explorer` on the left of window and choose `Add device` from the `Device explorer` contextual menu. This brings *score*'s device setup window. ![Device setup window]({{ site.img }}/reference/devices/add-device.gif \"score device setup\") In the Device setup window, in the left column, select the desired device type. Each device type has its setup panel depending of the used protocol. Please see the relevant device reference page to setup your device. ## Rate limiting ## Device explorer ### Shortcuts - Show: {% include shortcut.html content=\"Ctrl+Shift+D\" %} - Esc: deselect node ## Other - see [libossia protocol details](https://ossia.io/site-libossia/features/oscquery.html) ",
    "url": "https://ossia.io/score-docs/devices.html",
    "relUrl": "/devices.html"
  },"32": {
    "doc": "Embedded devices",
    "title": "Embedded devices",
    "content": "# Hardware support *ossia score* supports running on ARM under Raspberry Pi 3 and 4. We recommend a Raspberry Pi 4 for much better performance for audio processing, as well as better support for graphics feature due to its more advanced GPU. Other embedded boards will also likely work, they have just not been tested yet. If [Qt](https://qt.io) runs on the hardware then most likely *score* will also run -- see the following page for the reference hardware supported by Qt: [https://doc.qt.io/QtForDeviceCreation/qtdc-supported-platforms.html](https://doc.qt.io/QtForDeviceCreation/qtdc-supported-platforms.html) Please report to us if you try to build and run score on any other kind of exotic system ! ## Running on the Raspberry Pi Raspberry Pi 3 and 4 pre-made builds are accessible on [Github Actions](https://github.com/ossia/score/actions). Pi Zero, 1, 2 can technically work but no builds are currently being made for them. To use ossia score on the Pi, it is necessary to: - Use an up-to-date Raspbian Buster distribution (Stretch is not supported). [You can follow this guide](http://baddotrobot.com/blog/2019/08/29/upgrade-raspian-stretch-to-buster/). - Update the firmware to the kernel 5.10 at least: `sudo rpi-update` and reboot. - Enable `Full KMS` OpenGL settings in `sudo raspi-config`. Launch the utility, go to `6 Advanced Options`, then `GL Driver`, then select `GL (Full KMS)` and reboot. Check [this link](https://www.raspberrypi.org/documentation/configuration/raspi-config.md) for more information on the configuration process. Then you are good to go. Two scripts are provided: `ossia-score-x11` and `ossia-score-eglfs`. `ossia-score-x11` is for running under the normal desktop environment of the Pi. `ossia-score-eglfs` will run the graphics pipeline full-screen, bypassing the desktop environment entirely, which can be much more efficient - you don't even need to run X11 that way. But it is mostly useful in player mode, not for the score edition as there won't be any window borders / chrome. Note: we recommend not using the default Pi desktop environment: in our testing, switching to a lighter environment such as `i3wm` or `fluxbox` instead of the default Pi desktop made a large difference in performance and drop-outs for the scores. ## Building for the Raspberry Pi - *ossia score* build scripts: [https://github.com/ossia/score/tree/master/ci](https://github.com/ossia/score/tree/master/ci) - *ossia* SDK build scripts (building latest Qt, FFMPEG, etc): [https://github.com/ossia/sdk/tree/master/ARM/RPi4](https://github.com/ossia/sdk/tree/master/ARM/RPi4) They will produce binaries optimized for Pi 4, and that will also work on Pi 3. ## Caveats Some features are currently disabled -- namely, VST3 support as there aren't many Linux ARM VST3s. ## Performance optimization - If possible do not use PulseAudio but instead use ALSA directly. - If possible use a RT kernel. - If possible run with as few processes as possible - if you can avoid running any desktop environment / X11 / Wayland it will be faster. ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html",
    "relUrl": "/in-depth/embedded.html"
  },"33": {
    "doc": "Execution engine",
    "title": "Execution engine",
    "content": "# Execution engine # libossia execution ",
    "url": "https://ossia.io/score-docs/in-depth/execution.html",
    "relUrl": "/in-depth/execution.html"
  },"34": {
    "doc": "Device explorer",
    "title": "Device explorer",
    "content": " ",
    "url": "https://ossia.io/score-docs/panels/explorer.html",
    "relUrl": "/panels/explorer.html"
  },"35": {
    "doc": "Math expressions",
    "title": "Math expressions",
    "content": "# ExprTK support Several processes allow to write simple math expressions. Such processes include: - Audio Generator - Audio Mapping - Value Generator - Custom Mapping (Value) ![ExprTK]({{ site.img }}/reference/processes/exprtk.png) These expressions are solved within *score* using the [ExprTK library](https://www.partow.net/programming/exprtk/index.html \"ExprTK website\"). The expression can be written in the process built-in editor on multiple lines. Numerous math functions are available: `sin`, `cos`, `abs`, `log`, as well as the usual `pi`, etc. constants. ## Value generator ### Logistic function ```matlab if(m1 == 0) { m2 := 0.8; m1 := 1; } var r := 4 * a; m2 := r * m2 * (1 - m2); m2; ``` ## Value mapper ### Add jitter ```matlab var rnd_m := pow(2, 31); var rnd_a := 1103515245; var rnd_c := 12345; if(m2 == 0) { m2 := 1; m1 := 12345678; } var r := (rnd_a * m1 + rnd_c) % rnd_m; m1 := r; x + a * r / (2^33); ``` ## Audio generator ### Sine wave ```matlab var phi := 2 * pi * (20 + a * 500) / fs; m1[0] += phi; out[0] := b * cos(m1[0]); out[1] := b * cos(m1[0]); ``` ### Square wave ```matlab var phi := 2 * pi * (20 + a * 500) / fs; m1[0] += phi; var f := cos(m1[0]) > 0 ? b : -b; out[0] := f; out[1] := f; ``` ### Wobbly synth ```matlab var freq_l := 225 + cos(t/(100*(a+0.1))); freq_l := 2 * pi * m1[0] * freq_l * b / fs; var freq_r := 215 + sin(t/(100*(a+0.1))); freq_r := 2 * pi * m1[0] * freq_l * b / fs; m1[0] += 1; out[0] := b * cos( freq_l ); out[1] := b * cos( freq_r ); ``` ## Audio filter ### Crude distortion 2-channel version: ```matlab out[0] := clamp(0, tan(x[0]*log(1 + 200 * a)), 1); out[1] := clamp(0, tan(x[1]*log(1 + 200 * a)), 1); ``` Any number of channel version: ```matlab var n := x[]; for (var i := 0; i < n; i += 1) { var dist := tan(x[i]*log(1 + 200 * a)); out[i] := clamp(0, dist, 1); } ``` ## Available variables ### Everywhere * t: the current time * pos: the position in the interval * a, b, c: three provided controls * m1, m2, m3: three provided variables (which will keep their value across a tick) * In the audio cases they are arrays. ### Value mapping * x: the value of the current input * dt: the time delta ### Audio mapping * x: the value of the current sample * out: where to write the output * px: the value of the previous sample * fs: the sampling rate ### Value generator * dt: the time delta ### Audio generator * out: where to write the output * fs: the sampling rate ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html",
    "relUrl": "/processes/exprtk.html"
  },"36": {
    "doc": "FAQ",
    "title": "FAQ",
    "content": "Here is a list of (not necessarily) frequently asked questions. In case none of these answer yours, feel more than welcome to ask for help on the [ossia.io forum](https://forum.ossia.io) or send a message on [ossia score Gitter channel](https://gitter.im/ossia/score) where you will most likely find a handful of *score* users and developers. ",
    "url": "https://ossia.io/score-docs/faq.html",
    "relUrl": "/faq.html"
  },"37": {
    "doc": "Faust",
    "title": "Faust",
    "content": "# Important links * [Faust website & docs](https://faust.grame.fr) * [User library](https://github.com/ossia/score-user-library/tree/master/Presets/Faust) # Video tutorial ",
    "url": "https://ossia.io/score-docs/processes/faust.html",
    "relUrl": "/processes/faust.html"
  },"38": {
    "doc": "Glossary",
    "title": "Glossary",
    "content": "- TOC {:toc} ### Automation ### Branche ### Condition ### Device Devices are pieces of equipment you want to use with *score* in your creative project. These can be hardware (a Midi controller, a synthesizer) or software running locally or on the network. ### Device explorer The device explorer is the left panel. This is where devices involved in your project can be set up, browsed or monitored. ### Graph inspector The Graph inspector available in *score*'s top right panel allows to inspect a temporal object and its context. For example, select an interval on the scenario to list all attached processes. ### Interval Some block of time in the scenario. ### Process A process is an action used in the scenario to control some devices' parameter or other processes' parameters. *score* includes a number of processes such as breakpoint function-based automation, sub-scenarios, LFO or modulators or custom scripts. ### Processes explorer The processes explorer is accessible at the left panel in *score* main window. This is where you can browse and select some [processes]({{ site.baseurl }}/reference/glossary.html#process) to use in your scenario. ### Project folder This is where you can browse the content of the current project. ### Protocol ### Slot ### State ### Timeline ### Trigger ### User library The User library can be accessed in the left panel in *score* main window. It can contains various uer defined components such as devices setups, processes, presets. ",
    "url": "https://ossia.io/score-docs/reference/glossary.html",
    "relUrl": "/reference/glossary.html"
  },"39": {
    "doc": "Gradient",
    "title": "Gradient",
    "content": "# Gradient ",
    "url": "https://ossia.io/score-docs/processes/gradient.html",
    "relUrl": "/processes/gradient.html"
  },"40": {
    "doc": "Graphics pipeline",
    "title": "Graphics pipeline",
    "content": "# Graphics pipeline *score* uses [Qt RHI](https://www.qt.io/blog/graphics-in-qt-6.0-qrhi-qt-quick-qt-quick-3d) as graphics abstraction for the video pipeline. It is able to use OpenGL ES 2.0, Vulkan, Metal, and Direct 3D 11 in a very efficient way. *score* shaders are written with the [Interactive Shader Format](https://isf.video) specification. Video processes are combined into a dynamic render graph which is processed in a separate thread. Each process writes to a render target. ",
    "url": "https://ossia.io/score-docs/in-depth/video.html",
    "relUrl": "/in-depth/video.html"
  },"41": {
    "doc": "HTTP device",
    "title": "HTTP device",
    "content": "![Device setup window]({{ site.img }}/reference/devices/http-device.png \"score device setup\") Reference is not yet available. Feel more than welcome to ask for help on the [ossia.io forum](https://forum.ossia.io) or send a message on [ossia score Gitter channel](https://gitter.im/ossia/score) where you will most likely find a handful of *score* users and developers. ",
    "url": "https://ossia.io/score-docs/devices/http-device.html",
    "relUrl": "/devices/http-device.html"
  },"42": {
    "doc": "Image process",
    "title": "Image process",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/image.html",
    "relUrl": "/processes/image.html"
  },"43": {
    "doc": "In depth",
    "title": "In depth",
    "content": "# Advanced features This chapter describes various advanced use cases for *ossia score*, and explains how the software works. {: .fs-6 .fw-300 } ",
    "url": "https://ossia.io/score-docs/in-depth",
    "relUrl": "/in-depth"
  },"44": {
    "doc": "Home",
    "title": "Home",
    "content": "# Score documentation ![score window]({{ site.baseurl }}/assets/images/score-2.png) This is the documentation for *ossia score* v3.0.0. Browse by categories on the left, or if you are looking for a specific topic, check out the search bar at the top of the page. {: .text-red-300} Disclaimer: the documentation is currently in-progress. If you spot a missing / incomplete / wrong information, or even just a spelling mistake, you can click the link at the bottom of the page which allows to submit a fix request to the documentation. In the meantime, feel more than welcome to ask for help on the [ossia.io forum](https://forum.ossia.io) or send a message on [the ossia score gitter channel](https://gitter.im/ossia/score) where you will most likely find a handful of *score* users and developers. You may also find some information watching the [french video tutorials](https://vimeo.com/ossia). ",
    "url": "https://ossia.io/score-docs/",
    "relUrl": "/"
  },"45": {
    "doc": "Inspector",
    "title": "Inspector",
    "content": " ",
    "url": "https://ossia.io/score-docs/panels/inspector.html",
    "relUrl": "/panels/inspector.html"
  },"46": {
    "doc": "Interface overview",
    "title": "Interface overview",
    "content": "# *score* interface overview *Score* provides a unique window embedding all main features and toolboxes. From it, you can setup how your media applications and *score* will communicate, observe their parameters value navigate through their namespace in a structured way, store some parameters value in snapshots, draw some automations, structure you scenario in flexible ways and more. ![score main window]({{ site.img }}/quick-start/score-interface/score-main-window.png \"score main window\") All can be done from one of the 3 UI areas described below. ## Explorer panel On the left of *score* main window is the `Explorer panel`. This is where you can browse and manage the various contents needed for your project. ![Device explorer]({{ site.img }}/quick-start/score-interface/device_explorer.png \"Device explorer\") It comprises 4 main sections that can be switched using the icon at the bottom: ![Explorer main panels]({{ site.img }}/quick-start/score-interface/explorer-panels.png) 1. [Device explorer]({{ site.baseurl }}/reference/glossary.html#device-explorer): This is where you can setup the [devices]({{ site.baseurl }}/reference/glossary.html#device) (hardware or software devices on the network) you want to control from *score*. The `Device explorer` also offers a way to monitor or browse devices involved in your project, inspect its parameters and their behavior. This also is where you can grab parameters you want to save in a snapshot, write automations on as explained in the following pages. 2. [Processes explorer]({{ site.baseurl }}/reference/glossary.html#processes-explorer): This is where you can browse and select some [processes]({{ site.baseurl }}/reference/glossary.html#process) to use in your scenario to control various parameters of your devices or other processes. 3. [User library explorer]({{ site.baseurl }}/reference/glossary.html#user-library). This is where you can access some user defined assets. These can be devices setups, presets, processes collections amongst other things. 4. [Project folder]({{ site.baseurl }}/reference/glossary.html#project-folder): This is where you can browse the content of the current project. # Scenario editor At the center of the *score* window is the scenario editor. This is where you can write and edit the various parts of your project's flexible and interactive scenario. From there you can create some snapshots by dragging some parameters from the `Device explorer` at a particular time frame, create some automations by dragging parameters from the `Device explorer` on an interval, drop some audio or video medias from your hard drive to integrate them in your scenario. ![Scenario editor]({{ site.img }}/quick-start/score-interface/scenario_editor.png \"Scenario editor\") # Objects inspector panel On the right part of score main window is the `Object inspector`. It allows to dynamically inspect and setup the selected objects in the scenario. ![Object inspector]({{ site.img }}/quick-start/score-interface/dynamic_inspector.png \"Object inspector\") 1. Top part of the inspector is the structural context of the selected object. For example, the parent interval a process is attached to, the time point a state is placed on and its linked states, etc. 2. Bottom part are the various parameters of the selected object in the scenario: start time, duration and parameter address of an automation, source and target addresses of a mapping, its domain ranges, etc. # UI controls * Use right-click to edit controls precisely. * Many controls are available: sliders, color choosers, toggles... ",
    "url": "https://ossia.io/score-docs/quick-start/interface-overview.html",
    "relUrl": "/quick-start/interface-overview.html"
  },"47": {
    "doc": "Javascript",
    "title": "Javascript",
    "content": "# Javascript support ## Scripting in Javascript / QML. *score* allows to write scripts using the JavaScript language. These scripts can be used to write specific processes such as value mappers, audio generators. *score* uses JavaScript version ES7. See the [JavaScript reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference) for more information about JS language. It also uses QML (property real, etc.). See the [QML Reference](https://doc.qt.io/qt-5/qmlreference.html) for more information. Either code directly or a path to the file can be added to the Javascript code editor - if it's a file it will be watched for changes. JS can be used as a process both for intervals, and in states. * To add a JS process to an interval, simply drag'n'drop it from the Process Library to the interval. * To add a JS process to a state, right-click on the state in the Object Explorer, and choose \"Add Process\". ## Editing code An important thing to note is that the edited script *will not* be saved in the scenario if there are compilation errors. This is a known issue and likely to change. ## General syntax Every script must contain ```qml import Score 1.0 ``` somewhere at the top. A script defines a javascript object, with : - Input and output ports - Callbacks that are called either regularly on every tick, or on special events (start, stop, pause, resume). The smallest valid empty script looks like this: ```qml import Score 1.0 Script { tick: function(token, state) { } } ``` The tick function's two arguments give both timing and contextual information useful for writing algorithms. Please read the [Timing]({{ site.baseurl }}/in-depth/musical.html#timing) page to understand the timing concepts used in ossia score, in particular how model, physical and musical dates relate to each other. ### Available functions For now, only a very simple API to read / write messages from the device explorer is provided: ```js // Reads the current value of an address in the device explorer let value = Device.read(\"an:/address\"); // Sends a value to the device explorer Device.write(\"an:/address\", 123); ``` ### Token object Important note: due to the way numbers work in Javascript (that is, double-precision floating point numbers), and due to the timing units, scripts can only be expected to be accurate for representing durations no greater than 147 days. That is, if a time interval lasts a year, after 147 days the timing values returned by `prev_date`, `date`, ... may not be accurate anymore. This limit is pushed back to the hard limit of 414 years when using the C++ integer-based API instead. Note that this does not affect for instance, scores with normal durations which would loop back to the beginning - permanently running installations are safe. #### Properties - `previous_date`: the model date at which the tick starts. - `date`: the model date at which the tick ends - `parent_duration`: the nominal model duration of the closest parent interval. - `offset`: the model date at which we must start reading from our input. - `speed`: current speed (a multiplicative factor). - `tempo`: current tempo. - `musical_start_last_signature`: what is the position in quarter notes of the closest previous musical signature change to `previous_date`. - `musical_start_last_bar`: what is the position in quarter notes of the closest previous bar change to `previous_date`. - `musical_start_position`: what is the position of `previous_date` in quarter notes. - `musical_end_last_bar`: what is the position in quarter notes of the closest previous musical signature change to `date`. - `musical_end_position`: what is the position of `date` in quarter notes. - `signature_upper`: 6 in \"6/8\", at the start of the tick. - `signature_lower`: 8 in \"6/8\", at the start of the tick. #### Methods - `logical_read_duration()`: how long are we reading from the model data. - `physical_start(ratio)`: at which sample in the output must we start to write. - `physical_read_duration(ratio)`: how many samples are we reading from the input ports. - `physical_write_duration(ratio)`: how many samples are we writing to the output ports. - `to_physical_time_in_tick(time, ratio)`: convert a model time into a physical time. - `from_physical_time_in_tick(time, ratio)`: convert a time in physical dates, to a time in model dates. - `in_range(time)`: check that the model time given is indeed in the range of this tick. - `position()`: where are we in relation to our parent interval. 0 is the beginning, 1 is the nominal duration. If an interval has a greater max, or is infinite, this will go beyond 1. - `forward()`: is the time going forward in this tick (speed > 0). - `backward()`: is the time going backward in this tick (speed 0) { // Computer the sin() coefficient var freq = in1.value; // Notice how we get sample_rate from state. var phi = 2 * Math.PI * freq / state.sample_rate; // Where we must start to write samples var i0 = token.physical_start(state.model_to_physical); // Fill our array for(var s = 0; s 0 ? sample : 0; arr[i0 + s] = 0.3 * sample; } } // Write two audio channels, which will give stereo output by default in score. out1.setChannel(0, arr); out1.setChannel(1, arr); } } ``` ## Example of a MIDI transposer See the user library: Presets/JS/transpose.qml ## Port types ## Properties common to all ports ```qml FloatSlider { id: myVariableName // <- how you refer to it in the javascript Code objectName: \"The name shown in the score UI\" address: \"foo:/bar/baz\" // <- default address used when the object is created } ``` ## Audio Create an audio input: ```qml AudioInlet { id: in } ... var left = in.channel(0); var right = in.channel(1); console.log(left[0]); // print the first sample of the first channel for (var value in left) { ... } ``` Create an audio output: ```qml AudioOutlet { id: out } ... // set the data of channel 0 to the following: out.setChannel(0, [0.1, 0.0, 0.2, 0.0, -0.1, 0.0]); ``` ## MIDI Create a MIDI input: ```qml MidiInlet { id: in } ... var messages = in.messages(); for (var message in messages) { // Print the MIDI bytes console.log(message[0], message[1], message[2]); } ``` Create a MIDI output: ```qml MidiOutlet { id: out } ... // push a new message out.add([144, 64, 127]); // set & replace all the messages to be pushed out.setMessages([ [144, 64, 127], [144, 68, 127], [127, 30, 0] ]); ``` ## Messages Receiving: ```qml ValueInlet { id: in } ... // Print the latest message received console.log(in.value()); // Iterate through all the messages received for this tick, with their timestamp for (var message in in.values) { console.log(message.timestamp, message.value); } ``` Sending: ```qml ValueOutlet { id: out } ... // Use either out.setValue(1.234); // or out.addValue(timestamp, 1.234); ``` ## Controls Controls behave exactly like ValueInlet but show up as actual UI controls. They have as such relevant properties: min, max, etc. ```qml FloatSlider { min: 0.0 max: 1.0 init: 0.5 } ``` ```qml IntSlider { min: 0 max: 127 init: 0 } ``` ```qml Enum { choices: [\"foo\", \"bar\", \"baz\"] index: 2 } ``` ```qml Toggle { checked: true } ``` ```qml LineEdit { text: \"Hello world\" } ``` ",
    "url": "https://ossia.io/score-docs/processes/javascript.html",
    "relUrl": "/processes/javascript.html"
  },"48": {
    "doc": "Joystick device",
    "title": "Joystick device",
    "content": "![Device setup window]({{ site.img }}/reference/devices/joystick-device.png \"score device setup\") Reference is not yet available. Feel more than welcome to ask for help on the [ossia.io forum](https://forum.ossia.io) or send a message on [ossia score Gitter channel](https://gitter.im/ossia/score) where you will most likely find a handful of *score* users and developers. ",
    "url": "https://ossia.io/score-docs/devices/joystick-device.html",
    "relUrl": "/devices/joystick-device.html"
  },"49": {
    "doc": "LFO",
    "title": "LFO",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/lfo.html",
    "relUrl": "/processes/lfo.html"
  },"50": {
    "doc": "Library",
    "title": "Library",
    "content": "# Shortcuts - Process library: {% include shortcut.html content=\"Ctrl+Shift+P\" %} - System library: {% include shortcut.html content=\"Ctrl+Shift+B\" %} - Project library: {% include shortcut.html content=\"Ctrl+Shift+L\" %} ## Important folders: - Skins - Util/metro_tick.wav Util/metro_tock.wav - Addons - Presets ## Preview For now, sound files and audio files are previewed. More to come. ## Other features Double click on .score file : opens it ## User library Downloaded on first launch https://github.com/ossia/score-user-library Please contribute ## Settings: change the library path ## Project library - Need to save the file somewhere -> folder becomes the project folder. ",
    "url": "https://ossia.io/score-docs/panels/library.html",
    "relUrl": "/panels/library.html"
  },"51": {
    "doc": "Local device",
    "title": "Local device",
    "content": "While *score* can synchronise and automate your media softwares and hardware, it can also be remote-controlled, should you need to control your scenario execution using some hyper advanced next generation IA software, a custom sensor interface or whatever fits your needs. # Using score OSCQuery device score exposes its scenario execution parameters through OSCQuery protocol so they can be monitored and controlled locally or from any device on the network. For example, using score's own Device explorer, you will see when browsing available OSCQuery devices the score application and its address and port. ![score OSCQuery device]({{ site.img }}/reference/devices/score_local_device.png \"score local OSCQuery device\") Exposed parameters include: - 'exit': close current scenario - 'global_play': play score's current scenario - 'play': play score's current scenario - 'reconnect': reconnect a device - 'reinit': stop score execution and recall init state - 'running': report whether score is playing - 'stop': stop scenario execution - 'transport': set scenario main playhead at a particular point (in ms.) Below is a simple Max patcher provided in [ossia-max package](https://ossia.io/site-libossia/download.html#max-binding) illustrating remote control of score's transport. ![Remote transport]({{ site.img }}/reference/devices/remote_transport.png \"Remote transport\") # More parameters in the local tree In the [[preferences]] of the software, it is possible to enable the extended tree. This tree will create nodes for every interval, process, etc. This means that it will become possible to control any parameter in your score from OSC / OSCQuery. ",
    "url": "https://ossia.io/score-docs/devices/local-device.html",
    "relUrl": "/devices/local-device.html"
  },"52": {
    "doc": "Mapper device",
    "title": "Mapper device",
    "content": "![Device setup window]({{ site.img }}/reference/devices/mapper-device.png \"score device setup\") Reference is not yet available. Feel more than welcome to ask for help on the [ossia.io forum](https://forum.ossia.io) or send a message on [ossia score Gitter channel](https://gitter.im/ossia/score) where you will most likely find a handful of *score* users and developers. ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html",
    "relUrl": "/devices/mapper-device.html"
  },"53": {
    "doc": "Mapping (float)",
    "title": "Mapping (float)",
    "content": "# Mapping (float) ",
    "url": "https://ossia.io/score-docs/processes/mapping.html",
    "relUrl": "/processes/mapping.html"
  },"54": {
    "doc": "Media management",
    "title": "Media management",
    "content": "# Media management ## Paths to media If the path is relative, it will look in the project folder first. The project folder is the folder which contains the saved `.score` file. ",
    "url": "https://ossia.io/score-docs/in-depth/media.html",
    "relUrl": "/in-depth/media.html"
  },"55": {
    "doc": "MIDI processes",
    "title": "MIDI processes",
    "content": "# MIDI generators MIDI processes can write to a specific channel or directly to the root device through addresses. Velocity of MIDI notes can now be changed with shift-click. ## Piano roll ## Pattern sequencer # MIDI effects ## Arpeggiator ## Chord ## MIDI scale ## Quantifier ## MIDI pitch ## Pulse to note # Example: using the step sequencer to drive MIDI inputs ",
    "url": "https://ossia.io/score-docs/processes/midi.html",
    "relUrl": "/processes/midi.html"
  },"56": {
    "doc": "MIDI support",
    "title": "MIDI support",
    "content": "# MIDI communication MIDI communication is provided by two kind of devices, available from the [[Device explorer]]: * [[MIDI input device]] can be used to plug a MIDI keyboard to *score*. * [[MIDI output device]] can be used to send MIDI data from *score* to an external sequencer. # MIDI file support * The [piano roll]({{ site.baseurl }}/processes/midi.html#piano-roll) process supports MIDI files. > Simply drag'n'drop a MIDI file in the score ! # MIDI processing * See [[MIDI processes]] for a list of processes that can alter MIDI data: arpeggiator, etc. * You can write your custom MIDI processors, for instance with the [[Javascript]] or the [[C++ JIT]] process. ",
    "url": "https://ossia.io/score-docs/in-depth/midi.html",
    "relUrl": "/in-depth/midi.html"
  },"57": {
    "doc": "MIDI input device",
    "title": "MIDI input device",
    "content": "# MIDI input device To setup a device using Midi input, select `Midi input` in the Protocols column of the `Add device` window. ![Device setup window]({{ site.img }}/reference/devices/midiin-device.png \"score device setup\") In the `Devices` middle column, you can select your desired Midi input device. > If you plugged in your Midi controller after launching *score*, you may need to restart *score* so your controller appears in the Devices column. Optionally, you can set a custom name (or use the default one). ## Create whole tree option Under the name of your Midi input device, you can toggle on the `Create whole tree` option. This option will create all possible Midi messages as parameters of the device as illustrated below. Addresses in the namespace will be created using the following format: ///message number> ![Midi in whole tree]({{ site.img }}/reference/devices/midiin/midi-whole-tree.png \"Midi in whole tree\") Should you want not to automatically create a whole Midi namespace (i.e. and use Midi learn instead), just leave the option unset. ## Use Midi learn You can use the learn function to build your Midi input namespace with only the needed Midi message (rather than setting up the whole Midi namespace). To do so, once added the Midi device with the `Create whole tree` option off, in the `Device explorer`, right-click on your Midi input device name and select `Learn` from the contextual menu. ![Usig Midi learn]({{ site.img }}/reference/devices/midiin/midi-learn-1.png \"Using Midi learn\") This opens *score* Midi learn window. From then, *score* will monitor any incoming Midi message and store it under an address following the pattern mentioned above. When you are done sending the needed Midi message, click `Done` on the Midi learn window. All received Midi messages should now appear under your Midi input device name in the `Device explorer`. ",
    "url": "https://ossia.io/score-docs/devices/midiin-device.html",
    "relUrl": "/devices/midiin-device.html"
  },"58": {
    "doc": "MIDI output device",
    "title": "MIDI output device",
    "content": "# Midi output device To setup a device using Midi output, select `Midi output` in the Protocols column of the `Add device` window. ![Device setup window]({{ site.img }}/reference/devices/midiout/midiout-device.png \"score device setup\") In the `Devices` middle column, you can select your desired Midi input device. > If you plugged in your Midi device after launching *score*, you may need to restart *score* so your it appears in the Devices column. Optionally, you can set a custom name (or use the default one). ",
    "url": "https://ossia.io/score-docs/devices/midiout-device.html",
    "relUrl": "/devices/midiout-device.html"
  },"59": {
    "doc": "Minuit device",
    "title": "Minuit device",
    "content": "![Device setup window]({{ site.img }}/reference/devices/minuit-device.png \"score device setup\") Reference is not yet available. Feel more than welcome to ask for help on the [ossia.io forum](https://forum.ossia.io) or send a message on [ossia score Gitter channel](https://gitter.im/ossia/score) where you will most likely find a handful of *score* users and developers. ",
    "url": "https://ossia.io/score-docs/devices/minuit-device.html",
    "relUrl": "/devices/minuit-device.html"
  },"60": {
    "doc": "Mixer",
    "title": "Mixer",
    "content": "# Mixing busses Intervals can become mixing busses for all their child process. To use that feature, mark an interval as a bus in its inspector. The Audio panel then allows to change its volume / pan. Things with more than 2 channels will be available once we figure a proper UI for it - designers welcome as the code already supports it ! # Mixing console # Audio in-out ",
    "url": "https://ossia.io/score-docs/panels/mixer.html",
    "relUrl": "/panels/mixer.html"
  },"61": {
    "doc": "Modular workflow",
    "title": "Modular workflow",
    "content": "# Modular workflow *ossia score* is built upon an entirely modular foundation. At any point during edition, it is possible to switch from the temporal view, to the modular view, in order to patch processes together as easily as possible. The mode switching is operated by the buttons at the bottom of the software: ![Mode buttons]({{ site.img }}/in-depth/modular/buttons.png) Some processes will always appear in patch view: audio effects, generators, and more generally any process for which the effect does not depend on time-relative data. Here is a small score viewed in temporal mode (the default): ![temporal view]({{ site.img }}/in-depth/modular/temporal.png) Here is the same score viewed in modular mode: ![Modular view]({{ site.img }}/in-depth/modular/modular.png) It is also possible to disable the cables when the patching has been done and one wants to focus on the controls, the automations, etc: ![No cables]({{ site.img }}/in-depth/modular/nocables.png) This functionality is accessible through {% include shortcut.html content=\"Alt+Shift+G\" %}. ",
    "url": "https://ossia.io/score-docs/in-depth/modular-workflow.html",
    "relUrl": "/in-depth/modular-workflow.html"
  },"62": {
    "doc": "How to monitor activity ?",
    "title": "How to monitor activity ?",
    "content": "# How to monitor messages ? With `Logging` option activated in *score* preferences, you can for example check messages coming in and out of a selected process in the `Messages log panel` ({% include shortcut.html content=\"Ctrl+Shift+G\" %}) ![Messages log panel]({{ site.img }}/faq/monitor-activity/log-window.gif \"Messages log panel\") ",
    "url": "https://ossia.io/score-docs/faq/monitor-activity.html",
    "relUrl": "/faq/monitor-activity.html"
  },"63": {
    "doc": "Musical metrics",
    "title": "Musical metrics",
    "content": "# Musical metrics Musical metrics are hierarchic * The tempo, and musical position in an interval is either relative to this interval (if the 4/4 button in the inspector is pressed) or it's taking the musical information from its closest parent (recursively). This means that polyrhythmic scores are possible. To change the musical signatures, go into the children intervals, in full view. # Tempo Likewise, by default the tempo is the global one. Intervals support tempo curves, which can give them a different speed behaviour. The interval's children will all take this tempo unless another more precise tempo is given at a deeper nesting level. # Usage - Processes which are able to use tempo & metrics information (audio plug-ins, LFO, arpeggiator, etc) will do so automatically - Triggers can be quantified to fall on the next quantification date from when they are triggered. # Timing How timing works in ossia score. - Quantification - Model time - Physical time ",
    "url": "https://ossia.io/score-docs/in-depth/musical.html",
    "relUrl": "/in-depth/musical.html"
  },"64": {
    "doc": "How to run score without GUI ?",
    "title": "How to run score without GUI ?",
    "content": "# How to run *score* without GUI ? Score can run in the background while not opening its full UI (which may be handy for example when running score in a video installation). To do so, you can launch score from the Command line using the following: ```bash `$ ossia-score --no-gui --autoplay /home/oscar/my-score.score` ``` You may find other useful commands in the [[Command line API|command line reference page]]. ",
    "url": "https://ossia.io/score-docs/faq/nogui.html",
    "relUrl": "/faq/nogui.html"
  },"65": {
    "doc": "Non-linear timeline",
    "title": "Non-linear timeline",
    "content": "# Non-linear timeline In previous example, we used trigger points to add variation during the execution of time-lined contents (device's state recalling as well as automations) in the scenario. While trigger points bring flexibility in a timeline-based approach, things can be pushed a step further. You remember we noted in the [Saving and recalling devices state]({{ site.baseurl }}/quick-start/saving-and-recalling-devices-state.html \"Saving and recalling devices state\") page that *score* offers to connect dropped namespace selection to different preceding elements in the scenario. And *score* provides several ways to connect elements, one of them allowing to write and organize elements pretty much like you would do when designing a state machine. > To learn about the various connections features, please refer to the [in-depth topics]({{ site.baseurl }}/in-depth.html \"in-depth topics\") as well as the [reference manual]({{ site.baseurl }}/reference.html \"*score* reference manual\") to see how *score* engine works and the advanced authoring features it provides. In the scenario editor panel, you may create some elements by dragging a connection to a point in the timeline where you want to store a namespace state or start a process. This is where the `create widget` comes handy. In the illustration below, we can see that selecting a namespace state stored in the timeline brings the `create` widget: the yellow, blue and red crosses icons. We will focus here on the red one: it allows to *escape the timeline constraint* and automatically trigger elements attached to that connection. As seen above, clicking the red cross allows to drag a connection up to anywhere in the timeline. From there, we may adjust our device settings and drag a namespace selection from the `Device explorer` to store its state [as seen earlier]({{ site.baseurl }}/quick-start/states-and-automations-in-practice.html \"Store & recall devices' state\"). What does happen here ? Well, we are starting to scratch the surface of *score* special strength. When playing our scenario, *score* will recall our parameters stored states and execute automations as the play-head runs through the timeline, just like we saw earlier. But when reaching the starting point of this dashed connection, the play-head will kind of *jump* to the connected elements and continue the reading as time regularly passes by. This might look weird coming from a timeline-based approach but is actually extremely useful. While *score* can help to author elements of precise duration and evolution over time using its timeline as a default grid, it also allows to author state machine-like scenarios by *patching* timed processes. ## From timeline-based scenario to state machine This way of *patching* blocks of timed elements offers to construct your scenario in much more flexible ways that traditional DAW or timeline-based sequencers. As illustrated below, it allows to write scenarios running in loop for example as especially useful in interactive installations. ![Looping scenario]({{ site.img }}/quick-start/non-linear-timeline/looping-scenario.png) In the simple scenario above, *score* will execute the scenario as an infinite loop alternating a simple fade in, then jumping to the fade-out automations then jump back to fade-in automations. Of course, you can still use some [trigger points]({{ site.baseurl }}/quick-start/breaking-the-timeline.html) so the scenario waits before jumping to the next point. ![State machine scenario]({{ site.img }}/quick-start/non-linear-timeline/state-machine.png) ",
    "url": "https://ossia.io/score-docs/quick-start/non-linear-timelines.html",
    "relUrl": "/quick-start/non-linear-timelines.html"
  },"66": {
    "doc": "It does not work?",
    "title": "It does not work?",
    "content": "# The playback isn't running If when pressing \"Play\" you don't see anything moving or becoming green, it likely means that the sound card is improperly configured. Go to the [settings]({{ site.baseurl}}/reference/preferences.html#audio) and check that you have a valid sound card set. # The playback is running but I don't hear sound Go to the [settings]({{ site.baseurl}}/reference/preferences.html#audio) and check that the correct sound-card is selected for audio output (for instance, it happens that the sound card chosen is the HDMI output of the computer monitor, which may not have loudspeakers). ",
    "url": "https://ossia.io/score-docs/faq/doesnotwork.html",
    "relUrl": "/faq/doesnotwork.html"
  },"67": {
    "doc": "OSC device",
    "title": "OSC device",
    "content": "# OSC device ## Setting up communication with OSC device Once opened a new *score* project, right-click in the Device explorer on the left of *score* window and choose `Add device` from the Device explorer contextual menu. This brings *score*'s device setup window. ![Device setup window]({{ site.img }}/reference/devices/device_setup_window.png \"score device setup\") From the Protocols column, choose `OSC` and setup IP address your device is running on as well in & out ports. You may also specify a name for your device. For the demo purpose here, we will use the default `OSCdevice` name. When done, the Device explorer pane should display our device top node. ![OSC device top node]({{ site.img }}/reference/devices/osc_top_node.png \"OSC device top node\") Note: Should you need to change settings of your OSC device, the setup panel can be brought back by choosing `Edit` in the device contextual menu. We can then setup our device's OSC addresses we want to automate within *score*. ## Setting up OSC addresses ### Using OSC learn In the Device explorer pane, choose `Learn` in our device contextual menu. This opens up *score*'s OSC learning window. *score* will now monitor any OSC incoming value. For demo purpose here, we will use Vidvox's handy [OSC Test application](https://vdmx.vidvox.net/blog/freebies \"Vidvox OSC Test app\"). As soon as we send values to *score* from our OSC Test application, addresses get learned and displayed in the `OSC learning` window. ![Addresses learning]({{ site.img }}/reference/devices/osc_learning.png \"OSC learn\") When done, the Device explorer pane should display all learned OSC addresses. You can browse your device namespace, fold/unfold any node in the namespace hierarchy by clicking the arrow prepending each node. You can also see a parameter current value in your OSC device by selecting this parameter in *score* Device explorer and check its bottom section. ![Monitoring value changes]({{ site.img }}/reference/devices/testing_osc.png \"Monitoring distant parameter's value\") ### Adding addresses manually Should you need to setup your *score* project without having your OSC device opened, addresses can be added in the device explorer manually. Once having created an OSC device as explained above, choose `Add child` in the device contextual menu. As of *score* 3.0.0, each level of your parameter's OSC address is to be declared separately. Assuming we want to add the address `OSCdevice/track/1/volume`, we first need to create the 'track' node. From the OSC editor window, type `track` in the `Name` text field and leave default type `container` (that is: a node in the namespace above other nodes or parameters). Then from the freshly created `track` node contextual menu, choose `Add child` to create a `1` node, then from this node, choose `Add child` again to create our `volume` parameter. ![OSC node]({{ site.img }}/reference/devices/osc_node.png \"Create an OSC node\") For our `volume` parameter, we want to set the type as something else than `container`. For example, we will set up our parameter as a float value. ![Parameter type]({{ site.img }}/reference/devices/parameter_type.png \"Create an OSC parameter\") You may also edits some of the parameter's attributes as detailed in next step. ## Setting up parameters' attributes Once declared either using learn function or manually, parameter's general behaviour can be further defined by setting up its various attributes. When selecting a parameter in the Device explorer pane, its attributes can be displayed and edited in the bottom section of the pane. A dedicated window can also be opened by choose `Edit` in the parameter contextual menu. For each value type, a number of attributes can be defined, such as: value domain (min. and max. value), clip mode (parameter handling of value exceeding its domain), repetition filter, etc. ![Parameter attributes]({{ site.img }}/reference/devices/parameter_attributes.png \"Parameter's attributes\") ## Saving OSC device for later use When properly set up, your OSC device namespace can be exported and saved to disk for latter use. To do so, choose `Export device` in the device contextual menu. ",
    "url": "https://ossia.io/score-docs/devices/osc-device.html",
    "relUrl": "/devices/osc-device.html"
  },"68": {
    "doc": "OSCQuery device",
    "title": "OSCQuery device",
    "content": "# OSCQuery device *score* can communicate with devices using the OSCQuery protocol. ## What is OSCQuery ? As presented by the Vidvox Cie, The [OSC Query Protocol](https://github.com/vidvox/oscqueryproposal) is an agreed upon specification that extends the base functionality of OSC to make it easier to construct impromptu or improvisational interfaces between different systems. > The OSCQuery Protocol builds on top of OSC to provide a standardized way for systems to publish descriptions of their OSC Address Spaces in such a way that other environments can automatically interface with them with little or no setup. Within OSCQuery, a **server** is a host that provides a JSON data blob that describes the hierarchy of an OSC Address Space in a format that is both easy for humans and machine to interpret. Descriptions can include the type of data that is expected, the range of values that are accepted and other information about each container and method within the address space. Within OSCQuery, a **client** refers to a piece of software that browses and interacts with a remote server's OSC address space. See [Vidvox's detailed article](https://vdmx.vidvox.net/blog/oscquery) to read more about OSCQuery. ## Adding OSCQuery device Once opened a new score project, right-click in the Device explorer on the left of score window and choose `Add device` from the Device explorer contextual menu. This brings scoreâs device setup window. From the Protocols column, choose `OSCQuery`. You should see in the `Devices` column all OSCQuery compatibles devices available on the network. ![Device setup window]({{ site.img }}/reference/devices/oscquery-device.png \"score device setup\") Select the desired one from the list and click `Add`. *score* will then query the selected device and receive its full namespace. All nodes and parameters of the device should now appear in the `Device explorer`. ",
    "url": "https://ossia.io/score-docs/devices/oscquery-device.html",
    "relUrl": "/devices/oscquery-device.html"
  },"69": {
    "doc": "Panels",
    "title": "Panels",
    "content": "# Panels ",
    "url": "https://ossia.io/score-docs/panels.html",
    "relUrl": "/panels.html"
  },"70": {
    "doc": "MIDI pattern sequencer",
    "title": "MIDI pattern sequencer",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/patternist.html",
    "relUrl": "/processes/patternist.html"
  },"71": {
    "doc": "Plug-ins",
    "title": "Plug-ins",
    "content": "# Prerequisites This guide assumes that a development environment with all required dependencies has been set-up. Check [the \"hacking on score\" guide]({{ site.baseurl }}/development/build/hacking.html) for more information on how to do that. # Choosing the plug-in API to use *ossia score* provides two plug-in APIs: ## Fx API A simple API that can be used to implement quick audio / midi / control effects and generators in a single file. Processes implemented with that API are available [at the following address](https://github.com/ossia/score/tree/master/src/plugins/score-plugin-fx/Fx). To create a new plug-in, simply duplicate one of the files, change the metadata (name, UUID, etc. to differentiate it from other score plug-ins), and add it to the list in [this file](https://github.com/ossia/score/blob/master/src/plugins/score-plugin-fx/score_plugin_fx.cpp). When building score again, the plug-in should appear in the process list. A video explains the whole process: ## Score API A more advanced API that allows to customize pretty much every aspect of the software, but requires more work. The major part of the software *is* built with that API: every process in *score* comes from plug-ins. These plug-ins are located [in the score git repository](https://github.com/ossia/score/tree/master/src/plugins). The [addon tutorial](https://github.com/ossia/score-addon-tutorial) is an example of usage of the score API to showcase its capabilities. It is [documented here](https://github.com/ossia/score-addon-tutorial/tree/master/ReadMe). To develop new plug-ins that way, a [set-up script is provided](https://github.com/ossia/score/blob/master/tools/create-addon.sh). Simply invoke it with the name of your plug-in and it will create it in the `score/src/addons` folder: ```bash $ cd score $ tools/create-addon.sh fireworks Addon score-addon-fireworks successfully initialized $ ls src/addons CMakeLists.txt score-addon-fireworks ``` All the folders in that `score/src/addons` folder are treated by ossia score as custom addons that must be built along with the software. ",
    "url": "https://ossia.io/score-docs/development/plug-ins.html",
    "relUrl": "/development/plug-ins.html"
  },"72": {
    "doc": "Score preferences",
    "title": "Score preferences",
    "content": "## Audio Audio settings allow to configure which sound card score is going to use for playback. If no sound is needed, it is possible to set the \"Dummy\" engine which won't output sound. ## Execution Note that every execution settings change require stopping and restarting the score. ### Enable listening during execution This controls whether the Device Explorer panel updates its UI when the score is running. If there are thousands of parameters being updated all the time, monitoring them and updating the UI to show their new value can take some CPU usage which is not always required. ### Logging When \"Logging\" is selected in the settings, if you click on the title of a process, then the Messages panel ({% include shortcut.html content=\"Ctrl+Shift+G\" %}) will show all the messages getting in and out of that process. ### Benchmark When \"Benchmark\" is selected in the settings, the relative computation time of each process will be computed. This is useful for instance to find if there is a super intensive process taking too much CPU. ### Advanced execution settings #### Parallel Runs the processes on separate CPU cores as far as possible. #### Value compilation When doing a \"play from here\", this will try to guesstimate in which state the score should be at that point, by looking for the closest previous sent messages in the score and sending them to the devices. #### Transport value compilation Same as value compilation, but redoes it every time you do a transport while the score is playing, with the \"play\" tool. ",
    "url": "https://ossia.io/score-docs/reference/preferences.html",
    "relUrl": "/reference/preferences.html"
  },"73": {
    "doc": "Presets",
    "title": "Presets",
    "content": "# Presets ## Process presets Not available yet. ## Scenario presets 1. Select a part of the score. 2. Drag it with {% include shortcut.html content=\"Alt\" %} pressed into the user library, in some folder. 3. The selected part is now saved on the disk, in a `.scenario` file. 4. It can now be put in the score again by dragging it from the inspector. ",
    "url": "https://ossia.io/score-docs/presets.html",
    "relUrl": "/presets.html"
  },"74": {
    "doc": "Processes",
    "title": "Processes",
    "content": "# Processes *score* comes with a number of included processes. These cover various needs of action for advanced parameter control. This section of the manual covers the general usage of Processes as well a detailed documentation of each included Processes. ## General description *score* allows to handle a number of actions evolving through a defined amount of time. These processes can either be actions evolving during a given duration, such as automation of a given device's parameter, or actions activated only in a defined duration, such as mapping or LFO modulations. Processes are attached to an interval in the scenario. # Basics ## Create processes ### Using drag & drop #### From Device explorer Processes can be created by drag & dropping parameters from the `Device explorer` onto an existing interval in the scenario. The interval to which processes will be attached turns to yellow as the mouse with selection hovers it. ![Dropping parameters]({{ site.img }}/reference/processes/dropping-parameters.png \"Dropping parameters\") The `Device explorer` selection may contain one or several parameters. When multiple parameters are dropped, processes get stacked in different layers. #### From Libraries Processes can also be created by drag & dropping the desired process from the `Process library` or the `User library` in the scenario. When doing so, *score* automatically creates the interval to which process will get attached. ![Dropping processes]({{ site.img }}/reference/processes/dragging-processes.gif \"Dropping processes\") You may as well drop a process onto an existing interval. > Note that both namespace selection and processes selection can be dropped onto an interval to which some processes are already attached. Depending on the type of processes, these may be created on top of processes already in place or at a slot below. Audio, video and script files (Faust DSP, GLSL fragment shader, JS script...) can also be drag'n'dropped inside a scenario from your desktop's file manager. By default, dropping several processes at the same time stacks them in the same interval. Holding the Maj key while dropping will create sequential intervals for each item in the selection. ![Parallel or serial processes]({{ site.img }}/reference/processes/parallel-or-serial-processes.gif \"Parallel or serial processes\") ### Create from interval Processes can be created from an interval's widgets. Hover the interval to which attach a process to display the widget. Click the `+` widget to open the `Add process` window. ![Process addition widget]({{ site.img }}/reference/processes/add-process-from-interval.png \"Process addition widget\") From the `Add process window`, browse the various Processes types in the left panel, then choose the desired one. When done, click `+` button to attach process to the interval. ![Add process window]({{ site.img }}/reference/processes/add-process-from-interval-window.png \"Add process window\") ## Remove existing processes ### Using keyboard To remove a process, select it (for example by clicking on the slot background) and choose `Remove` from the `Object` menu ({% include shortcut.html content=\"Suppr\" %}/{% include shortcut.html content=\"Backspace\" %} key). > As of score v3.0.0-a19, make sure the process you want to remove is properly selected when bringing it to front (for example, check the inspector) ### From Graph inspector Processes can also be deleted from the `Graph inspector` at the top of *score*'s right panel. In the scenario, select the interval the process to remove is attached to. In the `Graph inspector`, browse through the attached processes and select the one to remove. Right-click to open the contextual menu and choose `Remove` (or use {% include shortcut.html content=\"Suppr\" %}/{% include shortcut.html content=\"Backspace\" %} key). ![Remove from Graph inspector]({{ site.img }}/reference/processes/remove-process-from-graph.png \"Remove from Graph inspector\") # Edit processes ## Fullsize edit Processes can be edited in full size. This is especially handy when you want to precisely edit a process such as an automation or mapping function. To display the process in full size, double-click on the interval the process is attached to. Process is now displayed using *score* central panel full width. Note that if several processes are attached to an interval, open them in full size will display all at once juxtaposed as shown below (see the `Multiple processes` interval). To exit full size mode (go back to parent scenario), click the desired node of the path displayed at the top or use the {% include shortcut.html content=\"Ctrl+Alt+â\" %} shortcut. ![Edit process in full size]({{ site.img }}/reference/processes/process-fullsize-edit.gif \"Edit process in full size\") ## Process Loops Time-based processes such as automations, media and sub-scenarios can be looped for as long as their parent interval is active. When selecting a process, either from the object panel or by clicking on process header, the loop option will appear in the `Inspector`. ![Process looping]({{ site.img }}/reference/common-practices/loopProcess.gif \"Process looping\") # Manage processes ## Fold/unfold attached processes Processes attached to an interval can easily be fold/unfold. This comes up especially usefull when working with a lot of processes while still maintaining some screen space and the scenario readable. To do so, click the blue arrow on top of the processes to fold/unfold. ![Fold/unfold processes]({{ site.img }}/reference/processes/fold-unfold-processes.gif \"Fold/unfold processes\") When selecting an interval, attached processes can also be fold/unfold using the `Show processes` & `Hide processes` entries from the `Object` menu. ![Fold/unfold processes]({{ site.img }}/reference/processes/fold-process-menu.png \"Fold/unfold processes\") ## Stacked slots Time-based processes (that is, processes whose *x* represents time, such as automations, media files) can be stacked on a same slot. This is the default presentation when dragging some parameters onto an interval or dragging a process from library onto an interval. In that case, top-most process is displayed in full color while processes in other layers or displayed in semi transparent color. You can of course re-arrange them as you want. ### Bring to front To change which process to display top-most, mouse over to the top of the process slot displaying the destination address. Clicking the address bar opens up a contextual menu listing all layered processes. Selecting one in the menu brings it to front. ![Bring process to front]({{ site.img }}/reference/processes/bring-to-front.png \"Bring process to front\") ### Move to new slot Processes can also be juxtaposed in several slots rather than stacked on top of the other. Grab the handle at the top left corner of the slot and drag & drop it on another slot to move it above another process or between different slots to insert it. ![Moving processes]({{ site.img }}/reference/processes/moving-processes.gif \"Moving processes\") > Processes can also be dragged & attached to a new interval ",
    "url": "https://ossia.io/score-docs/processes.html",
    "relUrl": "/processes.html"
  },"75": {
    "doc": "Supported protocols and formats",
    "title": "Supported protocols and formats",
    "content": "This page lists all the systems, file formats, etc... that *score* is able to inter-operate with. # Operating systems *score* works on Linux, macOS, Windows, and partially on the web platform. Its development mainly happens on an [ArchLinux](https://archlinux.org/) system. As *score* is built with [Qt](https://qt-project.org), it should be portable to [any system where Qt runs](https://doc.qt.io/qt-5/qpa.html). # Network protocols * [OSC (Open Sound Control)](http://opensoundcontrol.org/): the standard intermedia protocol. It is implemented through a [heavily modified version](https://github.com/jcelerier/oscpack) of [Ross Bencina's oscpack](https://www.rossbencina.com/code/oscpack). * Documented [here]({{ site.baseurl }}/devices/osc-device.html). * [OSCQuery](https://vdmx.vidvox.net/blog/oscquery): * Documented [here]({{ site.baseurl }}/devices/oscquery-device.html). * [Minuit](https://github.com/Minuit/minuit). * Documented [here]({{ site.baseurl }}/devices/minuit-device.html). * HTTP. * Documented [here]({{ site.baseurl }}/devices/http-device.html). * WebSockets. * Documented [here]({{ site.baseurl }}/devices/websockets-device.html). # Hardware protocols * [Art-Net](https://art-net.org.uk/) / DMX: the standard for lighting fixtures. Support is implemented through [libartnet](https://github.com/OpenLightingProject/libartnet), which has been integrated inside libossia. *score* is able to load fixtures definitions in the [open-fixture-library](https://github.com/OpenLightingProject/open-fixture-library) format. * Documented [here]({{ site.baseurl }}/devices/artnet-device.html). * Serial port: *score* can read/write directly through serial ports, either directly or through Bluetooth. Support is currently based on the Qt SerialPort library but is being ported to ASIO to allow it to run in environments that cannot use Qt. * Documented [here]({{ site.baseurl }}/devices/serial-device.html). * Game pads: they are supported through the [SDL2](https://libsdl.org) gamepad library. Most gamepads and joysticks should work without issue. * Documented [here]({{ site.baseurl }}/devices/joystick-device.html). * Wiimotes: they are supported through the [WiiUse](https://github.com/wiiuse/wiiuse) library. * Documented [here]({{ site.baseurl }}/devices/wiimote-device.html). * [Phidgets](https://www.phidgets.com): they are supported through an implementation in libossia. Note that *score* must be built from source with the Phidgets API for the Phidgets protocol to be enabled. # Audio systems * [JACK](https://jackaudio.org): support is implemented in libossia. * [PulseAudio](https://www.freedesktop.org/wiki/Software/PulseAudio/): experimental support is implemented in libossia. * [ALSA](https://alsa-project.org), the native Linux backend, supported through [PortAudio](https://www.portaudio.com/). * CoreAudio: the native macOS backend, supported through [PortAudio](https://www.portaudio.com/). * MME, WASAPI, WDMKS: the native Windows backends, supported through [PortAudio](https://www.portaudio.com/). * [ASIO](https://www.steinberg.net/en/company/technologies.html): the low-latency pro-audio Windows backend developed by [Steinberg](https://www.steinberg.net), supported through [PortAudio](https://www.portaudio.com/). * [SDL](https://libsdl.org): support is implemented in libossia. It is mainly used to provide audio for the WebAssembly build of *score*. # Transport synchronisation * [JACK](https://jackaudio.org) transport: *score* can act as a master or a slave. # MIDI All the MIDI support in *score* comes from the [libremidi](https://github.com/jcelerier/libremidi) library: For real-time communication, the following implementations are provided: * [ALSA](https://alsa-project.org), through either the raw or sequencer API. * [JACK](https://jackaudio.org). * The native operating systems MIDI API: MME for Windows, CoreMIDI for macOS. * [WebMIDI](https://www.w3.org/TR/webmidi/). In addition, *score* is able to load Standard MIDI files (SMF). See the [[MIDI|MIDI documentation]] for more information. # Audio file formats *score* uses [FFMPEG](https://ffmpeg.org/) for its audio needs. It should support most codecs and formats listed [at this page](https://ffmpeg.org/general.html#Audio-Codecs). *score* handles WAV files in a specific way, through the [dr_wav](https://github.com/mackron/dr_libs/) library, to allow for memory-mapping the data for large files. See the [sound file process documentation]({{ site.baseurl }}/processes/soundfile.html) for more information. # Video file formats *score* uses [FFMPEG](https://ffmpeg.org/) for its video needs. It should support most codecs and formats listed [at this page](https://ffmpeg.org/general.html#Video-Codecs). The exception is the [HAP codecs](https://hap.video): for maximum performance, decoding is done by *score* (which allows doing it on the graphics card, while FFMPEG's HAP decoding happens on the CPU which defeats the point of the codec). See the [video process documentation]({{ site.baseurl }}/processes/video.html) for more information. # Image file formats *score* uses Qt's [QImage](https://doc.qt.io/qt-5/qimage.html) for decoding images. The supported formats are PNG, GIF, JPEG. See the [image process documentation]({{ site.baseurl }}/processes/image.html) for more information. # Real-time media sharing *score* supports [Spout](https://spout.zeal.co/). For now it is limited to outputting a texture. # Graphics APIs *score* uses [Qt RHI](https://www.qt.io/blog/graphics-in-qt-6.0-qrhi-qt-quick-qt-quick-3d) as graphics abstraction for the video pipeline. It is able to use OpenGL ES 2.0, Vulkan, Metal, and Direct 3D 11 in a very efficient way. *score* shaders are written with the [Interactive Shader Format](https://isf.video) specification. See the [[shader|shader process documentation]] for more information on how to write *score* shaders. See the [[graphics pipeline|general video documentation]] for general information on the *score* graphics rendering pipeline. # Audio plug-ins *score* supports the following audio plug-in systems: * [Steinberg VST3](https://www.steinberg.net/en/company/technologies/vst3.html) on all platforms. * Documented [here]({{ site.baseurl }}/processes/audio-plugins.html#vst3). * [LV2](https://lv2plug.in) on Linux. Note that currently this requires building *score* on your own computer or use a Linux distro package. * Documented [here]({{ site.baseurl }}/processes/audio-plugins.html#lv2). * [Faust](https://faust.grame.fr/), the Faust programming language developed by GRAME. *score* embeds the Faust compiler and libraries. * Documented [here]({{ site.baseurl }}/processes/faust.html). * [Pure Data](https://puredata.info/) is embedded in *score* through [libpd](https://github.com/libpd/libpd). * Documented [here]({{ site.baseurl }}/processes/puredata.html). * It is possible to write simple audio instruments and effects with the [various math-expression processes]({{ site.baseurl }}/processes/exprtk.html). * It is possible to write simple audio instruments and effects with [the JavaScript process]({{ site.baseurl }}/processes/javascript.html). * It is possible to write more advanced instruments and effects in C++ with [the C++ JIT process]({{ site.baseurl }}/processes/cpp_jit.html). ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html",
    "relUrl": "/reference/protocols-and-formats.html"
  },"76": {
    "doc": "Pure Data integration",
    "title": "Pure Data integration",
    "content": "# Pure Data support ossia score supports running [Pure Data](http://msp.ucsd.edu/software.html) patches as processes. Simply drop a patch in the score to add it. This is done thanks to [libpd](https://github.com/libpd/libpd). ## Example The following Pure Data patch: ![Pd patch]({{ site.img }}/pd/pd-example-patch.png) Will look like this when loaded in score: ![Pd patch in score]({{ site.img }}/pd/pd-example-score.png) [This particular example can be downloaded in the user library](https://raw.githubusercontent.com/ossia/score-user-library/master/Presets/PureData/example-synthesizer.pd). Feel free to contribute your own useful patches [here](https://github.com/ossia/score-user-library/tree/master/Presets/PureData) ! ## Limitations For now do not use the \"Parallel\" execution mode when running Pd patches. ## Usage score will detect: - Audio inlets/outlets: `[adc~]`, `[dac~]` and create a corresponding audio input and output port. - Important ! You have to set in the inspector how many audio channels are needed, as they are multiplexed into a single port. - MIDI inlets/outlets: `[midiin]`, `[notein]`, `[controlin]`, `[midiout]`, `[noteout]`, `[controlout]` and will create a MIDI input and / or output port. - Value inlets/outlets: `[s] / [send]`, `[r] / [receive]`. It is possible (but still work-in-progress) to use the [libossia ossia.parameter syntax](https://ossia.io/ossia-docs/?plaintext--pd#creating-parameters) for the receives, so that score is able to create nice GUI controls. Additionally, a `widget` attribute can be used, which will directly create the expected widget, among: - intslider - floatslider - logfloatslider - intspinbox - toggle - button - lineedit - xyslider - hsvslider Valid cases would be (not all of them work yet): ``` [r myInput @type float @range -1 1] [r myInput @widget intslider @min 0 1000] [r myInput @type impulse] [r myInput @type bool @default true] [r myInput @unit color.hsv] ``` ## Editing the patch While editing the patch in real-time does not yet work, editing it when the score is stopped will reload it when execution is restarted. If a Purr Data, Pd-l2ork, or Pure Data binary is detected on the host computer (by looking into their default installations folders and in the PATH), then it will be possible to open the patch directly from score. ",
    "url": "https://ossia.io/score-docs/processes/puredata.html",
    "relUrl": "/processes/puredata.html"
  },"77": {
    "doc": "Pure Data integration",
    "title": "Pure Data integration",
    "content": "This documentation [has moved]({{ site.baseurl }}/processes/puredata.html). ",
    "url": "https://ossia.io/score-docs/docs/advanced/puredata.html",
    "relUrl": "/docs/advanced/puredata.html"
  },"78": {
    "doc": "Quick start",
    "title": "Quick start",
    "content": "# Quick start *ossia score* v3.0.0-a19 {: .label .label-green} This is the *ossia score* quick start manual. The following pages will guide you through [*score* interface]({{ site.baseurl }}/quick-start/interface-overview.html) and general workflow. They also cover some of the basic elements available to author advanced scenarios such as [snapshots saving and recalling]({{ site.baseurl }}/quick-start/saving-and-recalling-devices-state.html), [automations]({{ site.baseurl }}/quick-start/writing-automations.html), as well as using [audio]({{ site.baseurl }}/quick-start/working-with-audio.html) and [video]({{ site.baseurl }}/quick-start/working-with-video.html) files. These will get you started with the various ways *score* can be used to author flexible and structured scenarios for live performances, art installations or other media-based works. ![*score* scenario]({{ site.img }}/quick-start/what-is-score/score-main.png \"*score* scenario\") Enjoy advanced scenario authoring for your intermedia creation ! {: .fs-6 .fw-300 } ",
    "url": "https://ossia.io/score-docs/quick-start",
    "relUrl": "/quick-start"
  },"79": {
    "doc": "Recording",
    "title": "Recording",
    "content": "# Recording 1. Select addresses in the [[Device explorer]]. 2. Right-click in the score. 3. Select \"Record automations from here\". 4. Press play: recording will start as soon as a message is received. > This behaviour can be toggled in the [[Preferences]]. ",
    "url": "https://ossia.io/score-docs/in-depth/recording.html",
    "relUrl": "/in-depth/recording.html"
  },"80": {
    "doc": "Reference",
    "title": "Reference",
    "content": "# *score* reference manual This section of the manual goes through the various sections of *score* and bring detailed explanations. {: .fs-6 .fw-300 } ",
    "url": "https://ossia.io/score-docs/reference",
    "relUrl": "/reference"
  },"81": {
    "doc": "Remote Control",
    "title": "Remote Control",
    "content": "# Remote Control The two main ways to remote control score from the network are: - Through OSC and OSCQuery with the [Local device]({{ site.baseurl }}/devices/local-device.html). - Through a WebSocket API. The WebSocket API has been used to build a nice [graphical remote application](https://github.com/iscore-pfa/qml-remote). This page describes the low-level WebSocket API used by score, so that anyone can build their custom remotes similar to the one mentioned above.. ## Description Exposes some properties of the score over WebSockets: * Transport. * Viewing and controlling triggers. * Sending & receiving messages through the Device Explorer. * Executing JS code in the console. ## WebSocket API description The message format is JSON. ### Score -> client ```js { \"Message\": \"DeviceTree\" } ``` #### When a trigger starts executing: ```js { \"Message\": \"TriggerAdded\", \"Path\": \"/path/to/the/trigger\" } ``` #### When a trigger has finished executing: ```js { \"Message\": \"TriggerRemoved\", \"Path\": \"/path/to/the/trigger\" } ``` #### When an interval starts executing: ```js { \"Message\": \"IntervalAdded\", \"Path\": \"/path/to/the/interval\", \"Name\": \"machine_readable.name\", \"Label\": \"User-readable label\", \"Comment\": \"User-readable comment\", \"Speed\": 1.2345 } ``` #### When an interval has finished executing: ```js { \"Message\": \"IntervalRemoved\", \"Path\": \"/path/to/the/interval\" } ``` #### Heartbeat sent every few milliseconds: ```js { \"Intervals\": [ { \"Path\": \"/path/to/the/interval\", \"Progress\": 0.5, \"Speed\": 1., \"Gain\": 0.8 }, ... ] } ``` ### Client -> score #### Transport messages: ```js { \"Message\": \"Play\" } { \"Message\": \"Pause\" } { \"Message\": \"Stop\" } { \"Message\": \"Transport\", \"Milliseconds\": 40000 } ``` #### Console control: See the [Console API](console.html) for the allowed operations. ```js { \"Message\": \"Console\", \"Code\": \"someJSCodeToExecute()\" } ``` #### To trigger a trigger: ```js { \"Message\": \"Trigger\", \"Path\": \"/path/to/the/trigger\" } ``` #### To slow down or speed up an interval: ```js { \"Message\": \"IntervalSpeed\", \"Path\": \"/path/to/the/interval\", \"Speed\": 0.5 } ``` #### To change the gain of an interval: ```js { \"Message\": \"IntervalGain\", \"Path\": \"/path/to/the/interval\", \"Gain\": 0.5 } ``` #### To send a control message: ```js { \"Message\": \"Message\", \"Address\": \"device:/foo/bar@[color.rgb.r]\", \"Value\": { \"Float\": 1.23 } } ``` or, to showcase all possible types: ```js { \"Message\": \"Message\", \"Address\": \"device:/foo/bar\", \"Value\": { \"Tuple\": [ { \"Int\": 1 }, { \"Bool\": true }, { \"Char\": c }, { \"Vec2f\": [0.0, 1.1] }, { \"Vec3f\": [0.0, 1.1, 1.2] }, { \"Vec4f\": [0.0, 1.1, 1.3, 1.4] }, { \"Float\": 1.23 }, { \"String\": \"foo\" }, { \"Impulse\": null }, ] } } ``` #### To enable / disable listening Listening to an address means that when an address's value changes, the new value is forwarded to the remote client. ```js { \"Message\": \"EnableListening\", \"Address\": \"device:/foo/bar\" } ``` and ```js { \"Message\": \"DisableListening\", \"Address\": \"device:/foo/bar\" } ``` #### Control surface See [Control surface]({{ site.baseurl }}/processes/controlsurface.html). ",
    "url": "https://ossia.io/score-docs/in-depth/remote.html",
    "relUrl": "/in-depth/remote.html"
  },"82": {
    "doc": "Saving & recalling devices' state",
    "title": "Saving & recalling devices' state",
    "content": "*ossia score* provides a number of tools to author precise control of the various devices involved in your project. Here we will focus on two basic elements: - saving some devices' state (aka making snapshots) to be recalled during the execution of your scenario - writing automations for some parameters These illustrate a small part of the possibilities detailed later in the manual, but should get you started with *score* basic workflow. ## Storing your current device state Saving your device current state on the timeline is as easy as dragging parameters you want to save from the `Device explorer` to where you will want them to be recalled in the timeline. You can store at one place all parameters of a device or only part of, as well as parameters from different devices. > Note that when selecting a node in the namespace, all parameters below get selected. You may also select a single or many parameters using standard key combinations: > - {% include shortcut.html content=\"Shift+click\" %}: Select all parameters between clicked parameter and previously selected one > - {% include shortcut.html content=\"Ctrl+click\" %}: Add selected parameter to the current selection In the illustration below, we will just select the `gain` parameters from our ossia compatible Max synth patch and store their current value at the 5th bar of our scenario. As you drop these `gain` parameters on the timeline, you can see a blue disc circled in white gets created. Clicking this `state` icon, you can see in the inspector panel both parameters and their value listed as a tree-like view. ![Storing your device's current state]({{ site.img }}/quick-start/score-authoring/storing-states.gif) If you start playing your scenario using the play button from the transport ({% include shortcut.html content=\"space\" %} key), this state will get recalled and sent to your device as the play-head cross its position on the timeline. Should you need this state to be recalled earlier or later, just stop execution of the scenario (using stop button from the transport bar or {% include shortcut.html content=\"âµ\" %} key), then select and drag it along the timeline. > If your device does not echo back its parameters changes to *score*, you can still grab the parameters to store from the `Device explorer` and drop them on the Timeline. Then from the state inspector panel, type the desired value next to each parameter. > You may as well type the desired values in the `Device explorer` first, then drag & drop the parameters on the timeline. You may now make some changes to your device, then store this new state using the same drag & drop workflow. Note that when storing our device's second state in the timeline, *score* proposes to bind this snapshot to different elements in the timeline, as displayed with a dashed gray line. For now, we will just make sure this snapshot is bound to the first one we placed on the timeline. But be sure to check [dedicated section]({{ site.baseurl }}/common-practices.html) in the manual to see the features *score* provides to help you structure elements in your scenario. You can now start sequencing your devices' states in your scenario or read [detailed information about managing states and automations]({{ site.baseurl }}/quick-start/states-and-automations-in-practice.html). ",
    "url": "https://ossia.io/score-docs/quick-start/saving-and-recalling-devices-state.html",
    "relUrl": "/quick-start/saving-and-recalling-devices-state.html"
  },"83": {
    "doc": "Scenario",
    "title": "Scenario",
    "content": "The main view in score. The Scenario process allows to put a score inside another score, and to nest at an arbitrarily depth: think of it as the traditional DAW groups, on steroids. ### Features - Intervals: Muting intervals - Triggers: below - Conditions: below - Comment blocks ### Execution - Putting stuff on the top start state for it to run with Reinitialize - Putting stuff on the top end state for it to run when stop is pressed. ### Keyboard shortcuts - In a scenario with the navigation keys ( {% include shortcut.html content=\"â\" %}, {% include shortcut.html content=\"â\" %}, {% include shortcut.html content=\"â\" %}, {% include shortcut.html content=\"â\" %}). - To the parent scenario with {% include shortcut.html content=\"Ctrl+Alt+â\" %}. - Unroll all intervals' racks in a scenario {% include shortcut.html content=\"Ctrl+Alt+U\" %} - Fold all intervals' racks in a scenario {% include shortcut.html content=\"Ctrl+Alt+F\" %} ### Speed control Speed sliders appear on intervals while playing. To reset it: {% include shortcut.html content=\"Ctrl+Right Click\" %} ### List of drag'n'drops possible #### On intervals - Drop from the device explorer to an interval: create an automatoin curve. - Drop from the library explorer to an interval: create a process. - Drop a media from the library or the system to an interval: create a process. - Drop from the object list into a slot or in the interval #### Moving processes around - Drag the little â° icon somewhere else in the timeline. - In the same interval: reorders - In another interval: moves the process - In a blank space: creates a new interval from there and moves the process #### On processes - Generally, dropping a media on a process changes the content of the process. * dropping a new sound file on a sound process * dropping a new address from the explorer on an automation * etc... * file bugs if you see a case not implemented ! #### On states - Message list: add messages to the state - .cues files (created by dropping a state into the library) - .layer files #### From states - It is possible to select messages in a state and drop them either in the scenario, or on another state # Intervals ### Interpolate states # Graph links # Conditions ## Keyboard shortcuts Pressing suppr / backspace when a condition is selected removes it. # Triggers - It is possible to choose the desired behaviour for off-time triggers : either triggering them stops and restarts the subgraph immediately, or it stops the subgraph and will only restart it after a new triggering. This choice is done in the trigger inspector. ## Keyboard shortcuts Pressing suppr / backspace when a trigger is selected removes it. # Sequences - Auto-sequence settings ",
    "url": "https://ossia.io/score-docs/processes/scenario.html",
    "relUrl": "/processes/scenario.html"
  },"84": {
    "doc": "Serial device",
    "title": "Serial device",
    "content": "![Device setup window]({{ site.img }}/reference/devices/serial-device.png \"score device setup\") Reference is not yet available. Feel more than welcome to ask for help on the [ossia.io forum](https://forum.ossia.io) or send a message on [ossia score Gitter channel](https://gitter.im/ossia/score) where you will most likely find a handful of *score* users and developers. ",
    "url": "https://ossia.io/score-docs/devices/serial-device.html",
    "relUrl": "/devices/serial-device.html"
  },"85": {
    "doc": "Shader",
    "title": "Shader",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/shader.html",
    "relUrl": "/processes/shader.html"
  },"86": {
    "doc": "Shortcuts",
    "title": "Shortcuts",
    "content": "Below is a list of shortcuts available in *score* listed by scope of usage. # General - {% include shortcut.html content=\"Ctrl+Shift+D\" %}: Show `Device explorer` panel - {% include shortcut.html content=\"Ctrl+Shift+P\" %}: Show `Processes library` panel - {% include shortcut.html content=\"Ctrl+Shift+B\" %}: Show `System library` panel - {% include shortcut.html content=\"Ctrl+Shift+L\" %}: Show `Project library` panel - {% include shortcut.html content=\"Ctrl+Shift+C\" %}: Show `Console` panel - {% include shortcut.html content=\"Ctrl+Shift+G\" %}: Show `Messages log` panel # Conditions - {% include shortcut.html content=\"Suppr\" %}/{% include shortcut.html content=\"Backspace\" %}: Delete selected `condition` # Device explorer - {% include shortcut.html content=\"Esc\" %}: De-select node # Timeline - {% include shortcut.html content=\"â\" %}, {% include shortcut.html content=\"â\" %}, {% include shortcut.html content=\"â\" %}, {% include shortcut.html content=\"â\" %}: Navigate through the various linked elements on the `Timeline` - {% include shortcut.html content=\"Ctrl+Alt+â\" %}: Go back to parent scenario - {% include shortcut.html content=\"Ctrl+Alt+U\" %}: Unroll all processes attached to an interval - {% include shortcut.html content=\"Ctrl+Alt+F\" %}: Fold all processes attached to an interval # Trigger - {% include shortcut.html content=\"Suppr\" %}/{% include shortcut.html content=\"Backspace\" %}: Delete selected `trigger` ",
    "url": "https://ossia.io/score-docs/reference/shortcuts.html",
    "relUrl": "/reference/shortcuts.html"
  },"87": {
    "doc": "Signal display",
    "title": "Signal display",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/signal-display.html",
    "relUrl": "/processes/signal-display.html"
  },"88": {
    "doc": "Soundfiles",
    "title": "Soundfiles",
    "content": "- Drag'n'drop depuis le systÃ¨me - Drag'n'drop depuis la bibliothÃ¨que - Les fichiers avec information de tempo sont mis en boucle & timestretch automatiquement - 4 modes de timestretch: * Raw: pas de timestretch * Timestretch: timestretch normal, adaptÃ© aux instrus mÃ©lodiques * Timestretch (percussive): timestretch normal, adaptÃ© aux instrus percussifs * Repitch: change la hauteur - Les fichiers .wav / .aiff Ã  la mÃªme frÃ©quence d'Ã©chantillonnage que celle de score sont lus depuis le disque - Tous les autres fichiers sont convertis et stockÃ©s en RAM - Note : mentionner le ramdisk trick - Formats supportÃ©s: tous ceux supportÃ©s par ffmpeg * https://www.ffmpeg.org/general.html#Audio-Codecs - VST : scan dans la bibliothÃ¨que ",
    "url": "https://ossia.io/score-docs/processes/soundfile.html",
    "relUrl": "/processes/soundfile.html"
  },"89": {
    "doc": "Spout device",
    "title": "Spout device",
    "content": "# Spout device ",
    "url": "https://ossia.io/score-docs/devices/spout-device.html",
    "relUrl": "/devices/spout-device.html"
  },"90": {
    "doc": "States & automations in practice",
    "title": "States & automations in practice",
    "content": "# States & automations in practice In previous sections of this [quick start guide]({{ site.baseurl }}/quick-start.html), we saw two elementary methods to write scenarios for your project: saving & recalling some device's state as well as writing simple automations for its parameters. While elementary, these two very features still offer a lot of flexibility to author advanced scenarios for your creations project. This is made even more flexible given a handful of *score*'s practice-based workflow features. Rather than separating cue-like execution of messages toward your devices and time evolving processes such as automations, *score* offer a number of ways to easily mix two approaches in a unified workflow. ## Sequence mode ### Setting up auto-sequence mode A workflow you might find useful is the `auto-sequence` mode. As of *score* version 3.0.0-a19, `auto-sequence` is an option that needs to be activated from *score* preferences. To do so, bring *score* [Preferences window]({{ site.baseurl }}/reference/preferences.html \"*Score* preferences window\"). In the `Preferences` window, select the `User interface tab` then make sure the `auto-sequence` option is toggled on. ![Auto-sequence preference]({{ site.img }}/quick-start/states-and-automations-in-practice/auto-sequence-pref.png \"Auto-sequence preference\") ### Using auto-sequence In previous sections, we saw how to drag parameters from the `Device explorer` to easily store your device's state on the timeline as well as drag some processes (in this case automation). `Auto-sequence` kind of allows to do both in one go. In the example below, we will start by storing an initial state for our device. Then after making some changes to our device, rather than dropping again the parameters from the `Device explorer` to the timeline, we will use the blue `+` icon next to the state icon and drag the link to a later point in the timeline. What happens here is twofold: * storing a new state using that blue `+` button will store the device's state using the namespace selection defined in the previous stored state * using the `auto-sequence` option, *score* will automatically create some automations for the parameter that changed between initial state and newly created state > You may also store a new state by dragging from the blue `+` icon *without* `auto-sequence` mode activated. In that case, *score* will still use previous namespace selection to store parameters values but no automation will get created for changed parameters. ![Using auto-sequence mode]({{ site.img }}/quick-start/states-and-automations-in-practice/auto-sequence-mode.gif \"Using auto-sequence mode\") Of course, once these automations get auto-magically created, you can still edit their behavior over time and do whatever pleasing changes to their curve. You may also remove an automation, should you want not to include a parameter continuous change. ### Note on multiple automations editing In the example above, you can see multiple automation slots actually got superposed. You can bring to front any of the automations in background to edit it. To do so, click on the address bar at the top of the slot to open up the list of superposed parameters 'automation. Select in the contextual menu the one to edit. Once to front (displayed in red), it can be edited. > When multiple automations are stacked, frontmost one is drawn with a red line, while the ones behind are drawn with a greyed out line ![Select from stack]({{ site.img }}/quick-start/states-and-automations-in-practice/stacked-slots.gif \"Select from stack\") You can also remove an automation from the stack by clicking on a slot background. Bring the contextual menu using right-click and select `remove`. ![Remove automation]({{ site.img }}/quick-start/states-and-automations-in-practice/remove-automation.png \"Remove automation\") ",
    "url": "https://ossia.io/score-docs/quick-start/states-and-automations-in-practice.html",
    "relUrl": "/quick-start/states-and-automations-in-practice.html"
  },"91": {
    "doc": "Step sequencer",
    "title": "Step sequencer",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/step.html",
    "relUrl": "/processes/step.html"
  },"92": {
    "doc": "Texture generator",
    "title": "Texture generator",
    "content": "# Example ```cpp extern \"C\" void score_rgba(unsigned char* rgba, int width, int height, int t) { int k = 0; for(int j = 0; j < height; j++) { for(int i = 0; i < width; i++) { rgba[k++] = 255 * t * k / (width * height); rgba[k++] = 255 * t * k / (width * height); rgba[k++] = 255 * t * k / (width * height); rgba[k++] = 255 * t * k / (width * height); } } } ``` ",
    "url": "https://ossia.io/score-docs/processes/texgen.html",
    "relUrl": "/processes/texgen.html"
  },"93": {
    "doc": "Address system",
    "title": "Address system",
    "content": "# Unit system *score* provides various features to ease the management of parameters. These are specially useful when writing complex processes (e.g automations). ## Addressing items in arrays When a parameter of a declared device defines a set of values (e.g parameters defining an XYZ position or an RGB color), items in this array can accessed independently using a special syntax: a parameter address may be followed by an integer (starting from zero) in brackets, which will select a given member. For example, using `aDevice:/anAddress@[1]` as a destination address of an automation will send the automation value to the *second* element in the array. If the array contains sub-arrays (for instance for a matrix), it is possible to address sub-elements like this: ``` aDevice:/anAddress@[1][0] ``` For instance, given ``` aDevice:/anAddress == [ [a, b], [c, d] ] ``` the above address will change the value of `c`. > Note that without specifying an index, messages and automations sent to array parameters (i.e. `vec2f`, `vec3f`, `list`) will affect all items in the array. ## Using unit conversion Parameters of a device may be declared with a specific unit (for instance, parameters defining a position in space or a color). *score* embeds an automatic unit conversion mechanism for advanced automations. When using these parameters in ports of processes, it is also possible to set an unit set on them, with the same syntax than for array indexing: using `aDevice:/anAddress@[angle.radian]` as a destination address of an automation will send the value in this unit (ie. radian). The value will be converted back to the address's original unit when sent over the network protocol, which may be for instance degrees. > The complete list of supported units is available [in the libossia documentation](https://ossia.io/ossia-docs/#units). In the case of multi-dimensional quantities (for instance, colors, 3D positions), it is also possible to select a single component: ``` aDevice:/anAddress[color.rgb.r] ``` as the output of an automation will only update the red component. This also works with different units: for instance, if the device has a parameter declared with the `color.rgb` unit, it is possible to control its hue with `parameter@[color.hsv.h]`. ## Pattern matching It is possible to control a set of addresses with pattern matching. For instance, given the following OSC device: ![An OSC device with repeated parameters]({{ site.img }}/in-depth/pattern-match.png) It is possible to send an automation to ``` OSCdevice:/sub/*/level ``` to control all the levels with a single curve. > The complete reference of the supported pattern matching syntax is available [here](https://ossia.io/ossia-docs/#pattern-matching). ",
    "url": "https://ossia.io/score-docs/in-depth/unit-system.html",
    "relUrl": "/in-depth/unit-system.html"
  },"94": {
    "doc": "Video",
    "title": "Video",
    "content": "## Usage - Drag'n'drop video from system or user library - Videos loop by default - Simplest way to play a video: * Add a window device * Drop the video * Select the output port of the video process and assing it to the window device ## Support - Formats de fichiers supportÃ©s: tous ceux supportÃ©s par ffmpeg * https://www.ffmpeg.org/general.html#Video-Codecs - Formats de pixels supportÃ©s: * RGB * BGR * RGBA * BGRA * YUV420 * YUV422 ",
    "url": "https://ossia.io/score-docs/processes/video.html",
    "relUrl": "/processes/video.html"
  },"95": {
    "doc": "What is score ?",
    "title": "What is score ?",
    "content": "# What is *score* ? *ossia score* offers advanced tools to ease the authoring of time exigent projects involving medias: flexible score for a live performance, interactive scenario for an intermedia installation, game-like state machine scenarios, etc. It thus provides a unified place to write automations for the parameters of the devices involved in the project, provides means to author efficient mappings from device A to device B or to modulate some devices parameters using generative processes and so on. ## Advanced time sequencing environment When having to author scenarios for interactive art, music and sound performances, one often has to rely on two approaches: - DAW / timeline-based software offering tools for fine time editing and parameters automation - cue-based software offering great flexibility in live situation While both approaches have numerous advantages, they also draw some limits in some advanced media-based productions: First type hardly offers (if any) flexibility in live situation regarding how events actually evolve in time. Second type makes it hard if possible at all to control precisely processes evolving over time. *score* thus aims at bridging the gap between these two models in a unified environment. By combining a flexible timeline with a patch-like authoring process, it allows to write [precisely timed processes such as automations]({{ site.baseurl }}/quick-start/writing-automations.html) or more fancy parameters control and modulation while still [maintaining some variations as the scenario is executed]({{ site.baseurl }}/quick-start/breaking-the-timeline.html). But it also allows authoring [open and non-linear scenarios]({{ site.baseurl }}/quick-start/non-linear-timelines.html) yet still including some time-dependent processes. ![score scenario]({{ site.img }}/quick-start/what-is-score/score-main.png) ## Interoperability-based *ossia score* aims to fully integrate with the favorite tools of artists and musicians involved in advanced media authoring. It allows to remotely control various commercial or custom software and hardware as well as to work with audio or video medias right from the app. While *score* itself offers some audio and video features, it does not aim at being an \"All in one\" super software (hence forcing intermedia authors to give up their personal toolset expertise). On the contrary, *score* was built from the ground up to be **as interoperable as possible**. Users remain thus free to use their tools of choice, be it their favorite VJing software, custom audio synthesis app or any specialized toolset. ![score main window]({{ site.img }}/quick-start/working-with-devices/ecosystem.png \"score main window\") *score 3.0.0* supports a number of protocols such as [[MIDI support|MIDI]], [Open Sound Control]({{ site.baseurl }}/devices/osc-device.html), [OSCQuery]({{ site.baseurl }}/devices/oscquery-device.html) or [serial port]({{ site.baseurl }}/devices/serial-device.html) making it easy to use score as the central hub of a project and thus author fine relationships between medias. ",
    "url": "https://ossia.io/score-docs/quick-start/what-is-score.html",
    "relUrl": "/quick-start/what-is-score.html"
  },"96": {
    "doc": "Wiimote device",
    "title": "Wiimote device",
    "content": "![Device setup window]({{ site.img }}/reference/devices/wiimote-device.png \"score device setup\") Reference is not yet available. Feel more than welcome to ask for help on the [ossia.io forum](https://forum.ossia.io) or send a message on [ossia score Gitter channel](https://gitter.im/ossia/score) where you will most likely find a handful of *score* users and developers. ",
    "url": "https://ossia.io/score-docs/devices/wiimote-device.html",
    "relUrl": "/devices/wiimote-device.html"
  },"97": {
    "doc": "Window device",
    "title": "Window device",
    "content": "![Device setup window]({{ site.img }}/reference/devices/window-device.png \"score device setup\") Reference is not yet available. Feel more than welcome to ask for help on the [ossia.io forum](https://forum.ossia.io) or send a message on [ossia score Gitter channel](https://gitter.im/ossia/score) where you will most likely find a handful of *score* users and developers. ",
    "url": "https://ossia.io/score-docs/devices/window-device.html",
    "relUrl": "/devices/window-device.html"
  },"98": {
    "doc": "Working with audio",
    "title": "Working with audio",
    "content": "# Working with audio in *score* ## Audio setup Before playing with audio sound files or synthesis in *score* you may want to ensure audio settings are properly set up. To do so, open the `Preferences` window from the *score* menu and select the \"Audio\" tab on the left side of the Preferences window. Then select the Driver you want to use as well as the desired audio interface and related options (Buffer size and sample rate). ![Audio setup]({{ site.img }}/quick-start/working-with-audio/audio-preferences.png \"Audio setup\") Make sure the audio switch is properly lit on. ![Audio switch]({{ site.img }}/quick-start/working-with-audio/audio_switch.png \"Audio setup\") When done, you are ready to go ! ## Playing audio file Audio files can easily be integrated to your scenario. Just grab your file on your disk and drop it at the desired place on the timeline. Click the play button (or use {% include shortcut.html content=\"spacebar\" %} shortcut) and that's it. > By default, *score* will use the main stereo output of your audio interface. Be sure to read the [audio routing]({{ site.baseurl }}/in-depth/audio-routing.html \"Audio routing\") section for more information. ![Playing audio files]({{ site.img }}/quick-start/working-with-audio/reading-audio-file.gif \"Playing audio files\") ## Combining audio medias and devices control Audio files (and more generally medias) can be fully combined with device's automations or other processes in the scenario. Thus you can write medias playing and distant devices remote control at a single place. In the example below, we just want to play one audio file synchronously with some automations already in place. Rather than dropping our audio file on the timeline and align things by hand, we can just drop it on the automation's slot top bar so it sticks to it. In this particular case, you may notice though that the dropped sound file is shorter than the full length of the automation. Just bring the audio file inspector and toggle the loop mode. Now when playing the scenario, the audio file will loop as long as the automation is playing. ![Audio file and other processes]({{ site.img }}/quick-start/working-with-audio/combining-audio-and-other-processes.gif \"Audio files and other processes\") ## Adding audio effects Contrary to some other software, *score* does not rely so much on the studio recording metaphor involving the usual mixing desk, per track FX, fixed busses and so on. Rather, it relies much more on a time-based modular approach. Without going too much into details of *score* engine for now, let's just say that it offers to have a unique sound chain (audio source, FX or modulators) for each block of the scenario involving audio. As illustrated below, you can easily add some FX, either from the built-in library or some VST effects installed on your computer to some audio file in your scenario. When dropped, a patch-like workspace is created. For demonstration purpose here, we will just add a simple gain controller. Below the sound file waveform, you can note a red dot. This actually is the audio output. We can just drag a cable from this red dot down to the red circle (its input) at the left of the gain FX. When playing the scenario, audio file will now play through this simple FX and go out to the main output. Again, when the play-head gets beyond the automation's slot, audio will get fully bypassed (hence preventing from any CPU drain). ![Adding FX]({{ site.img }}/quick-start/working-with-audio/simple-audio-fx.gif) Feel free to get familiar with this patch workspace using other audio FX or VST of your own collection. > You may also note some yellow circle and frames. These are respectively control input and output of some processes parameter. Should you feel adventurous, have fun checking the `Control` folder in the `Process library` to add modulation to your FX's parameters. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-audio.html",
    "relUrl": "/quick-start/working-with-audio.html"
  },"99": {
    "doc": "Working with devices",
    "title": "Working with devices",
    "content": "# Working with your devices *score* is built from the ground up to be as interoperable as possible with other devices involved in a creative project, whether they are software or hardware. ![score main window]({{ site.img }}/quick-start/working-with-devices/ecosystem.png \"score main window\") When starting a project in *score* you will most likely want to start by setting up the devices *score* will be used with. ## Setting up your devices network These devices can be freely added to your current score project from the [[Device explorer]] panel. Bring up the `Device explorer` panel using {% include shortcut.html content=\"Ctrl+Shift+D\" %} shortcut or click on the bottom left icon. ![Device explorer icon]({{ site.img }}/quick-start/working-with-devices/de-button.png \"Device explorer icon\") Right click on the `Device explorer` panel and setup the desired communication protocol between *score* and your device. ![Adding a device to *score* project]({{ site.img }}/quick-start/working-with-devices/add-device.gif \"Adding a device to *score* project\") > Remember you can at any time edit the settings of your device using right-click, then select `Edit` from the contextual menu *Score* currently support the following devices types: | OSC | Utilities | Hardware | Web | Lights | Audio | Video |:----------------------------------------------------------------|:------------------------------------------------------------|:----------------------------------------------------------------|:------------------------------------------------------------|:----------------------------------------------------------------||:----------------------------------------------------------------|:----------------------------------------------------------------| [OSCQuery]({{ site.baseurl }}/devices/oscquery-device.html) | [Mapper]({{ site.baseurl }}/devices/mapper-device.html) | [Midi in]({{ site.baseurl }}/devices/midiin-device.html) | [HTTP]({{ site.baseurl }}/devices/http-device.html)| [Artnet]({{ site.baseurl }}/devices/artnet-device.html) | [Audio]({{ site.baseurl }}/devices/audio-device.html) | [Window]({{ site.baseurl }}/devices/window-device.html) | [OSC]({{ site.baseurl }}/devices/osc-device.html) | [Local]({{ site.baseurl }}/devices/local-device.html) | [Midi out]({{ site.baseurl }}/devices/midiout-device.html) | [WS]({{ site.baseurl }}/devices/ws-device.html) |||[Camera]({{ site.baseurl }}/devices/camera-device.html) | [Minuit]({{ site.baseurl }}/devices/minuit-device.html) | [Serial]({{ site.baseurl }}/devices/serial-device.html) | | | [Joystick]({{ site.baseurl }}/devices/joystick-device.html) | | | [Wiimote]({{ site.baseurl }}/devices/wiimote-device.html) | Detailed explanations on these various device types and corresponding setup options can be found in the [Reference pages]({{ site.baseurl }}/devices.html). ## Devices' namespace browsing The `Device explorer` provides a unified view of your devices parameters as a tree-like structure. Devices are exposed as a number of nodes (some key parts of your device) and their related parameters. From there you can freely browse your distant devices for monitoring or more importantly to select the parameters you want to control from *score*, as detailed in the next topic of this [Quick start]({{ site.baseurl }}/quick-start/saving-and-recalling-devices-state.html \"Scenario authoring\"). ![Device's namespace browsing]({{ site.img }}/quick-start/working-with-devices/de-browsing.gif \"Device's namespace browsing\") ## Monitor & remote control of parameters The `Device explorer` also provides detailed information about your device parameters. Clicking a parameter from the namespace brings a dedicated inspector at the bottom, displaying it s various attributes, such as its current value (assuming your device echoes back its parameters value to *score*). You may also use this inspector to remotely change the value of a parameter (e.g. for testing purpose). ![Device's parameter inspector]({{ site.img }}/quick-start/working-with-devices/bi-directionnal.gif \"Device's parameter inspector\") ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-devices.html",
    "relUrl": "/quick-start/working-with-devices.html"
  },"100": {
    "doc": "Working with video",
    "title": "Working with video",
    "content": "# Working with video in *score* *score* embeds a number of video related features: media playing and processing, GPU-based processing or synthesis. Just like with audio files, video files can be thus fully integrated to your scenario along with other processes and distant devices controls. ## Supported formats *Score* supports all video files formats supported by the FFMPEG library. More info on supported files can be found on the [FFMPEG website](https://www.ffmpeg.org/general.html#Video-Codecs). ## Video setup First, we need to setup our video output. To do so, we need to add a video window device to our project by right-clicking in the `Device explorer` pane and choose `Add device` from the contextual menu. In the device setup window, mouse over to the video category and choose the `Window device`. You may define a name for the video window or use the default name and click `Add`. When done, *score* creates a black video window. ![Create window device]({{ site.img }}/quick-start/working-with-video/window-device.gif) > You can see in the `Device explorer` a device with the defined name. You will note that contrary to other devices used so far, this one has no parameters under its root node. This device basically only creates a video output window and rendering context. ## Playing a video file To add a video file to the timeline, just grab your file on disk or in the project library and drop it where you want on the timeline. As seen in the [previous section]({{ site.baseurl }}/quick-start/working-with-audio.html \"Working with audio within score\"), you may as well drop it on top of some already existing automation's slot so your video file is aligned. When done, a slot containing the video file gets created on the timeline. You can adjust the length of the slot to fit the part of the video file to play following the different key frames of the video. ![Add video file]({{ site.img }}/quick-start/working-with-video/adding-video-file.gif) We now need to route our video file to our video window so it gets displayed when execution the scenario. Just as with other processes used so far (automation as well as audio), the video slot has an output port at the bottom: the white filled circle. Click on the output port to bring its inspector. From there, select your window video device in the dedicated menu. Now when executing your scenario, video file will get properly displayed in window. ![Video routing]({{ site.img }}/quick-start/working-with-video/video-routing.gif) ## Adding video effects Again, similarly to audio files, you can easily drag some effects. From the `Processes Library` pane or from the `User library` pane, select one of the processes in the `GFX` category. In the example below, we will use the `Shader filter` provided in *score* default library. We now need to route our video file to the video effect rather than from the window. To do so, drag a cable from the video file output port (the white filled circle) to the effect input port (the white framed circle) as shown below. Then from the shader output port inspector, choose `GFX` as output. ![Video effect routing]({{ site.img }}/quick-start/working-with-video/video-effect-routing.gif) You may now play with the shader parameters using its UI as the scenario is executed or write some automations. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-video.html",
    "relUrl": "/quick-start/working-with-video.html"
  },"101": {
    "doc": "Writing automations",
    "title": "Writing automations",
    "content": "## Writing continuous parameter control *Score* provides numerous features to control continuously your devices' parameters over time. These are provided through the `Process` library available by clicking on the icon at the bottom left of score window (or using {% include shortcut.html content=\"Ctrl+Shift+P\" %} shortcut). ![Process library panel]({{ site.img }}/quick-start/score-authoring/process_library.gif \"Process library panel\") In the example below, we will just create a basic breakpoint function-based automation for one of our device's parameter, by selecting the `automation (float)` in the Process library, then drag & drop it where we want it on the timeline. ![Creating automation]({{ site.img }}/quick-start/score-authoring/create_automation.gif) When done, you will see on the timeline a simple 1 segment linear default automation. Let's now assign our device parameter as a destination for this simple automation process. Click on the automation's slot top bar to bring its inspector. Now from the `Device explorer` drag the desired parameter on the address field. The automation is now assigned to our parameter. When playing the scenario, our device's parameter will get driven by an ascending ramp as the playhead goes across the automation slot. Of course, you may refine your automation function by double-clicking in the automation slot to add more points or select a segment and use {% include shortcut.html content=\"Shift+Drag\" %} to add curvature to the segment as well as using other advanced features as detailed in the [Automation reference page]({{ site.baseurl }}/processes/automation_float.html). > You can extend your automation slot by dragging along the timeline its top right corner (the blue dot). By default, slot will get extended will preserving the automation length so you can further write your automation. You may also drag it using {% include shortcut.html content=\"Cmd+Drag\" %} to scale the automation as the slot gets extended along the timeline ### Full size edit When further precision is required to edit your automation, you can double-click the name above the automation slot (here \"automation (float)\" to zoom in the slot and edit the automation in full size. ![Full size edit]({{ site.img }}/quick-start/score-authoring/fullsize-edit.gif) When done editing, you can go back to your scenario full view using {% include shortcut.html content=\"Cmd+â\" %} or clicking on your scenario name beneath the time ruler. ![Leaving full size edit]({{ site.img }}/quick-start/score-authoring/leaving_full_size.png) ",
    "url": "https://ossia.io/score-docs/quick-start/writing-automations.html",
    "relUrl": "/quick-start/writing-automations.html"
  },"102": {
    "doc": "WebSocket device",
    "title": "WebSocket device",
    "content": "![Device setup window]({{ site.img }}/reference/devices/ws-device.png \"score device setup\") Reference is not yet available. Feel more than welcome to ask for help on the [ossia.io forum](https://forum.ossia.io) or send a message on [ossia score Gitter channel](https://gitter.im/ossia/score) where you will most likely find a handful of *score* users and developers. ",
    "url": "https://ossia.io/score-docs/devices/ws-device.html",
    "relUrl": "/devices/ws-device.html"
  }
}
